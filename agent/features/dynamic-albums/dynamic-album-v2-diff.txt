
diff --git a/server/src/dtos/album.dto.ts b/server/src/dtos/album.dto.ts
index 40e51ef72..79f6dac1d 100644
--- a/server/src/dtos/album.dto.ts
+++ b/server/src/dtos/album.dto.ts
@@ -46,6 +46,12 @@ export class CreateAlbumDto {
   @Optional()
   description?: string;
 
+  @ValidateBoolean({ optional: true })
+  dynamic?: boolean;
+
+  @Optional()
+  filters?: object | null;
+
   @Optional()
   @IsArray()
   @ValidateNested({ each: true })
@@ -65,6 +71,12 @@ export class UpdateAlbumDto {
   @IsString()
   description?: string;
 
+  @ValidateBoolean({ optional: true })
+  dynamic?: boolean;
+
+  @Optional()
+  filters?: object | null;
+
   @ValidateUUID({ optional: true })
   albumThumbnailAssetId?: string;
 
@@ -123,6 +135,8 @@ export class AlbumResponseDto {
   ownerId!: string;
   albumName!: string;
   description!: string;
+  dynamic!: boolean;
+  filters!: object | null;
   createdAt!: Date;
   updatedAt!: Date;
   albumThumbnailAssetId!: string | null;
@@ -148,6 +162,8 @@ export type MapAlbumDto = {
   sharedLinks?: AuthSharedLink[];
   albumName: string;
   description: string;
+  dynamic: boolean;
+  filters: object | null;
   albumThumbnailAssetId: string | null;
   createdAt: Date;
   updatedAt: Date;
@@ -188,6 +204,8 @@ export const mapAlbum = (entity: MapAlbumDto, withAssets: boolean, auth?: AuthDt
   return {
     albumName: entity.albumName,
     description: entity.description,
+    dynamic: entity.dynamic,
+    filters: entity.filters,
     albumThumbnailAssetId: entity.albumThumbnailAssetId,
     createdAt: entity.createdAt,
     updatedAt: entity.updatedAt,
diff --git a/server/src/enum.ts b/server/src/enum.ts
index d211420ab..80d420190 100644
--- a/server/src/enum.ts
+++ b/server/src/enum.ts
@@ -675,3 +675,17 @@ export enum AssetVisibility {
   HIDDEN = 'hidden',
   LOCKED = 'locked',
 }
+
+export enum AlbumFilterType {
+  TAG = 'tag',
+  PERSON = 'person',
+  LOCATION = 'location',
+  DATE_RANGE = 'date_range',
+  ASSET_TYPE = 'asset_type',
+  METADATA = 'metadata',
+}
+
+export enum AlbumFilterOperator {
+  AND = 'and',
+  OR = 'or',
+}
diff --git a/server/src/queries/access.repository.sql b/server/src/queries/access.repository.sql
index 402bbdcfa..c488b0ace 100644
--- a/server/src/queries/access.repository.sql
+++ b/server/src/queries/access.repository.sql
@@ -151,6 +151,39 @@ where
   "sessions"."userId" = $1
   and "sessions"."id" in ($2)
 
+-- AccessRepository.dynamicAlbum.checkOwnerAccess
+select
+  "dynamic_albums"."id"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" in ($1)
+  and "dynamic_albums"."ownerId" = $2
+  and "dynamic_albums"."deletedAt" is null
+
+-- AccessRepository.dynamicAlbum.checkSharedAlbumAccess
+select
+  "dynamic_albums"."id"
+from
+  "dynamic_albums"
+  left join "dynamic_album_shares" as "albumShares" on "albumShares"."dynamicAlbumId" = "dynamic_albums"."id"
+  left join "users" on "users"."id" = "albumShares"."userId"
+  and "users"."deletedAt" is null
+where
+  "dynamic_albums"."id" in ($1)
+  and "dynamic_albums"."deletedAt" is null
+  and "users"."id" = $2
+  and "albumShares"."role" in ($3, $4)
+
+-- AccessRepository.dynamicAlbum.checkSharedLinkAccess
+select
+  "shared_links"."dynamicAlbumId"
+from
+  "shared_links"
+where
+  "shared_links"."id" = $1
+  and "shared_links"."dynamicAlbumId" in ($2)
+
 -- AccessRepository.memory.checkOwnerAccess
 select
   "memories"."id"
diff --git a/server/src/queries/dynamic.album.repository.sql b/server/src/queries/dynamic.album.repository.sql
new file mode 100644
index 000000000..1167b9781
--- /dev/null
+++ b/server/src/queries/dynamic.album.repository.sql
@@ -0,0 +1,535 @@
+-- NOTE: This file is auto generated by ./sql-generator
+
+-- DynamicAlbumRepository.getById
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.getOwned
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."ownerId" = $1
+  and "dynamic_albums"."deletedAt" is null
+order by
+  "dynamic_albums"."createdAt" desc
+
+-- DynamicAlbumRepository.getShared
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  exists (
+    select
+    from
+      "dynamic_album_shares" as "shares"
+    where
+      "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      and "shares"."userId" = $1
+  )
+  and "dynamic_albums"."deletedAt" is null
+order by
+  "dynamic_albums"."createdAt" desc
+
+-- DynamicAlbumRepository.getMetadataForIds
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.getAssets
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.getAssetCount
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.getFirstAssetForThumbnail
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.delete
+delete from "dynamic_albums"
+where
+  "id" = $1
+
+-- DynamicAlbumRepository.softDelete
+update "dynamic_albums"
+set
+  "deletedAt" = now()
+where
+  "id" = $1
+
+-- DynamicAlbumRepository.restore
+update "dynamic_albums"
+set
+  "deletedAt" = $1
+where
+  "id" = $2
diff --git a/server/src/queries/shared.link.repository.sql b/server/src/queries/shared.link.repository.sql
index 1044c1c88..ff71b1a80 100644
--- a/server/src/queries/shared.link.repository.sql
+++ b/server/src/queries/shared.link.repository.sql
@@ -101,7 +101,8 @@ order by
 select distinct
   on ("shared_links"."createdAt") "shared_links".*,
   "assets"."assets",
-  to_json("album") as "album"
+  to_json("album") as "album",
+  to_json("dynamicAlbum") as "dynamicAlbum"
 from
   "shared_links"
   left join "shared_link__asset" on "shared_link__asset"."sharedLinksId" = "shared_links"."id"
@@ -147,13 +148,48 @@ from
       "albums"."id" = "shared_links"."albumId"
       and "albums"."deletedAt" is null
   ) as "album" on true
+  left join lateral (
+    select
+      "dynamic_albums".*,
+      to_json("owner") as "owner"
+    from
+      "dynamic_albums"
+      inner join lateral (
+        select
+          "users"."id",
+          "users"."email",
+          "users"."createdAt",
+          "users"."profileImagePath",
+          "users"."isAdmin",
+          "users"."shouldChangePassword",
+          "users"."deletedAt",
+          "users"."oauthId",
+          "users"."updatedAt",
+          "users"."storageLabel",
+          "users"."name",
+          "users"."quotaSizeInBytes",
+          "users"."quotaUsageInBytes",
+          "users"."status",
+          "users"."profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+          and "users"."deletedAt" is null
+      ) as "owner" on true
+    where
+      "dynamic_albums"."id" = "shared_links"."dynamicAlbumId"
+      and "dynamic_albums"."deletedAt" is null
+  ) as "dynamicAlbum" on true
 where
   "shared_links"."userId" = $1
   and (
     "shared_links"."type" = $2
     or "album"."id" is not null
+    or "dynamicAlbum"."id" is not null
   )
   and "shared_links"."albumId" = $3
+  and "shared_links"."dynamicAlbumId" = $4
 order by
   "shared_links"."createdAt" desc
 
diff --git a/server/src/repositories/access.repository.ts b/server/src/repositories/access.repository.ts
index 8863d117b..66907a496 100644
--- a/server/src/repositories/access.repository.ts
+++ b/server/src/repositories/access.repository.ts
@@ -219,6 +219,33 @@ class AssetAccess {
       return new Set<string>();
     }
 
+    // First, check if this is a dynamic album shared link
+    const sharedLinkInfo = await this.db
+      .selectFrom('shared_links')
+      .leftJoin('albums', (join) =>
+        join.onRef('albums.id', '=', 'shared_links.albumId').on('albums.deletedAt', 'is', null),
+      )
+      .select(['shared_links.userId', 'albums.dynamic', 'albums.ownerId'])
+      .where('shared_links.id', '=', sharedLinkId)
+      .executeTakeFirst();
+
+    if (!sharedLinkInfo) {
+      return new Set<string>();
+    }
+
+    // If this is a dynamic album shared link, check if the assets belong to the album owner
+    if (sharedLinkInfo.dynamic && sharedLinkInfo.ownerId) {
+      return this.db
+        .selectFrom('assets')
+        .select('assets.id')
+        .where('assets.id', 'in', [...assetIds])
+        .where('assets.ownerId', '=', sharedLinkInfo.ownerId)
+        .where('assets.deletedAt', 'is', null)
+        .execute()
+        .then((assets) => new Set(assets.map((asset) => asset.id)));
+    }
+
+    // For regular albums, use the existing logic
     return this.db
       .selectFrom('shared_links')
       .leftJoin('albums', (join) =>
@@ -245,7 +272,7 @@ class AssetAccess {
         sql`array[${sql.join([...assetIds])}]::uuid[] `,
       )
       .execute()
-      .then((rows) => {
+      .then((rows: any[]) => {
         const allowedIds = new Set<string>();
         for (const row of rows) {
           if (row.assetId && assetIds.has(row.assetId)) {
diff --git a/server/src/repositories/album.repository.ts b/server/src/repositories/album.repository.ts
index a52fa9c99..2c0484d5c 100644
--- a/server/src/repositories/album.repository.ts
+++ b/server/src/repositories/album.repository.ts
@@ -121,22 +121,21 @@ export class AlbumRepository {
       return [];
     }
 
-    return (
-      this.db
-        .selectFrom('assets')
-        .$call(withDefaultVisibility)
-        .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'assets.id')
-        .select('album_assets.albumsId as albumId')
-        .select((eb) => eb.fn.min(sql<Date>`("assets"."localDateTime" AT TIME ZONE 'UTC'::text)::date`).as('startDate'))
-        .select((eb) => eb.fn.max(sql<Date>`("assets"."localDateTime" AT TIME ZONE 'UTC'::text)::date`).as('endDate'))
-        // lastModifiedAssetTimestamp is only used in mobile app, please remove if not need
-        .select((eb) => eb.fn.max('assets.updatedAt').as('lastModifiedAssetTimestamp'))
-        .select((eb) => sql<number>`${eb.fn.count('assets.id')}::int`.as('assetCount'))
-        .where('album_assets.albumsId', 'in', ids)
-        .where('assets.deletedAt', 'is', null)
-        .groupBy('album_assets.albumsId')
-        .execute()
-    );
+    // This method only handles regular (non-dynamic) albums.
+    // Dynamic album metadata is calculated in the service layer using search functionality.
+    return this.db
+      .selectFrom('assets')
+      .$call(withDefaultVisibility)
+      .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'assets.id')
+      .select('album_assets.albumsId as albumId')
+      .select((eb) => eb.fn.min(sql<Date>`("assets"."localDateTime" AT TIME ZONE 'UTC'::text)::date`).as('startDate'))
+      .select((eb) => eb.fn.max(sql<Date>`("assets"."localDateTime" AT TIME ZONE 'UTC'::text)::date`).as('endDate'))
+      .select((eb) => eb.fn.max('assets.updatedAt').as('lastModifiedAssetTimestamp'))
+      .select((eb) => sql<number>`${eb.fn.count('assets.id')}::int`.as('assetCount'))
+      .where('album_assets.albumsId', 'in', ids)
+      .where('assets.deletedAt', 'is', null)
+      .groupBy('album_assets.albumsId')
+      .execute();
   }
 
   @GenerateSql({ params: [DummyValue.UUID] })
@@ -337,6 +336,9 @@ export class AlbumRepository {
    * - Removing references of thumbnails to assets outside the album
    * - Setting a thumbnail when none is set and the album contains assets
    *
+   * This method only handles regular (non-dynamic) albums.
+   * Dynamic album thumbnails are handled in the service layer.
+   *
    * @returns Amount of updated album thumbnails or undefined when unknown
    */
   async updateThumbnails(): Promise<number | undefined> {
@@ -351,20 +353,24 @@ export class AlbumRepository {
           .limit(1),
       }))
       .where((eb) =>
-        eb.or([
-          eb.and([
-            eb('albumThumbnailAssetId', 'is', null),
-            eb.exists(this.updateThumbnailBuilder(eb).select(sql`1`.as('1'))), // Has assets
-          ]),
-          eb.and([
-            eb('albumThumbnailAssetId', 'is not', null),
-            eb.not(
-              eb.exists(
-                this.updateThumbnailBuilder(eb)
-                  .select(sql`1`.as('1'))
-                  .whereRef('albums.albumThumbnailAssetId', '=', 'album_assets.assetsId'), // Has invalid assets
+        eb.and([
+          // Only process regular albums (not dynamic albums)
+          eb.or([eb('dynamic', 'is', null), eb('dynamic', '=', false)]),
+          eb.or([
+            eb.and([
+              eb('albumThumbnailAssetId', 'is', null),
+              eb.exists(this.updateThumbnailBuilder(eb).select(sql`1`.as('1'))), // Has assets
+            ]),
+            eb.and([
+              eb('albumThumbnailAssetId', 'is not', null),
+              eb.not(
+                eb.exists(
+                  this.updateThumbnailBuilder(eb)
+                    .select(sql`1`.as('1'))
+                    .whereRef('albums.albumThumbnailAssetId', '=', 'album_assets.assetsId'), // Has invalid assets
+                ),
               ),
-            ),
+            ]),
           ]),
         ]),
       )
diff --git a/server/src/repositories/asset.repository.ts b/server/src/repositories/asset.repository.ts
index f3e798d2b..afc2a6b87 100644
--- a/server/src/repositories/asset.repository.ts
+++ b/server/src/repositories/asset.repository.ts
@@ -11,22 +11,22 @@ import { AssetJobStatusTable } from 'src/schema/tables/asset-job-status.table';
 import { AssetTable } from 'src/schema/tables/asset.table';
 import { ExifTable } from 'src/schema/tables/exif.table';
 import {
-  anyUuid,
-  asUuid,
-  hasPeople,
-  removeUndefinedKeys,
-  truncatedDate,
-  unnest,
-  withDefaultVisibility,
-  withExif,
-  withFaces,
-  withFacesAndPeople,
-  withFiles,
-  withLibrary,
-  withOwner,
-  withSmartSearch,
-  withTagId,
-  withTags,
+    anyUuid,
+    asUuid,
+    hasPeople,
+    removeUndefinedKeys,
+    truncatedDate,
+    unnest,
+    withDefaultVisibility,
+    withExif,
+    withFaces,
+    withFacesAndPeople,
+    withFiles,
+    withLibrary,
+    withOwner,
+    withSmartSearch,
+    withTagId,
+    withTags,
 } from 'src/utils/database';
 import { globToSqlPattern } from 'src/utils/misc';
 
@@ -51,6 +51,7 @@ interface AssetBuilderOptions {
   isTrashed?: boolean;
   isDuplicate?: boolean;
   albumId?: string;
+  dynamicAlbumId?: string;
   tagId?: string;
   personId?: string;
   userIds?: string[];
diff --git a/server/src/repositories/download.repository.ts b/server/src/repositories/download.repository.ts
index aef00f1ed..61f0cb4ab 100644
--- a/server/src/repositories/download.repository.ts
+++ b/server/src/repositories/download.repository.ts
@@ -1,9 +1,9 @@
 import { Injectable } from '@nestjs/common';
 import { Kysely } from 'kysely';
 import { InjectKysely } from 'nestjs-kysely';
-import { AssetVisibility } from 'src/enum';
 import { DB } from 'src/schema';
-import { anyUuid } from 'src/utils/database';
+import { anyUuid, searchAssetBuilder } from 'src/utils/database';
+import { FilterUtil } from 'src/utils/filter.util';
 
 const builder = (db: Kysely<DB>) =>
   db
@@ -20,21 +20,35 @@ export class DownloadRepository {
     return builder(this.db).where('assets.id', '=', anyUuid(ids)).stream();
   }
 
-  downloadMotionAssetIds(ids: string[]) {
+  downloadAssetPaths(ids: string[]) {
     return builder(this.db).select(['assets.originalPath']).where('assets.id', '=', anyUuid(ids)).stream();
   }
 
-  downloadAlbumId(albumId: string) {
+  downloadAlbumId(albumId: string, isDynamic: boolean = false, filters?: any, userId?: string) {
+    // For dynamic albums, use search functionality
+    if (isDynamic && filters && userId) {
+      return this.downloadDynamicAlbum(filters, userId);
+    }
+
+    // For regular albums, use the existing logic
     return builder(this.db)
       .innerJoin('albums_assets_assets', 'assets.id', 'albums_assets_assets.assetsId')
       .where('albums_assets_assets.albumsId', '=', albumId)
       .stream();
   }
 
-  downloadUserId(userId: string) {
-    return builder(this.db)
-      .where('assets.ownerId', '=', userId)
-      .where('assets.visibility', '!=', AssetVisibility.HIDDEN)
+  private downloadDynamicAlbum(filters: any, userId: string) {
+    // Convert filters to search options using the centralized utility
+    const searchOptions = FilterUtil.convertFiltersToSearchOptions(filters, userId);
+
+    // Use searchAssetBuilder to create the query and then add the download-specific fields
+    return searchAssetBuilder(this.db, searchOptions)
+      .innerJoin('exif', 'assets.id', 'exif.assetId')
+      .select(['assets.id', 'assets.livePhotoVideoId', 'exif.fileSizeInByte as size'])
       .stream();
   }
+
+  downloadUserId(userId: string) {
+    return builder(this.db).where('assets.ownerId', '=', userId).stream();
+  }
 }
diff --git a/server/src/repositories/search.repository.ts b/server/src/repositories/search.repository.ts
index 9026b795c..0ae1c4b52 100644
--- a/server/src/repositories/search.repository.ts
+++ b/server/src/repositories/search.repository.ts
@@ -90,6 +90,7 @@ export interface SearchPeopleOptions {
 
 export interface SearchTagOptions {
   tagIds?: string[];
+  tagOperator?: 'and' | 'or';
 }
 
 export interface SearchAlbumOptions {
diff --git a/server/src/repositories/shared-link.repository.ts b/server/src/repositories/shared-link.repository.ts
index 0875b535e..f9c6dcc4f 100644
--- a/server/src/repositories/shared-link.repository.ts
+++ b/server/src/repositories/shared-link.repository.ts
@@ -167,13 +167,95 @@ export class SharedLinkRepository {
       .execute();
   }
 
+  @GenerateSql({ params: [DummyValue.UUID] })
+  async getById(id: string) {
+    return this.db
+      .selectFrom('shared_links')
+      .selectAll('shared_links')
+      .leftJoinLateral(
+        (eb) =>
+          eb
+            .selectFrom('shared_link__asset')
+            .whereRef('shared_links.id', '=', 'shared_link__asset.sharedLinksId')
+            .innerJoin('assets', 'assets.id', 'shared_link__asset.assetsId')
+            .where('assets.deletedAt', 'is', null)
+            .selectAll('assets')
+            .innerJoinLateral(
+              (eb) => eb.selectFrom('exif').selectAll('exif').whereRef('exif.assetId', '=', 'assets.id').as('exifInfo'),
+              (join) => join.onTrue(),
+            )
+            .select((eb) => eb.fn.toJson('exifInfo').as('exifInfo'))
+            .orderBy('assets.fileCreatedAt', 'asc')
+            .as('a'),
+        (join) => join.onTrue(),
+      )
+      .leftJoinLateral(
+        (eb) =>
+          eb
+            .selectFrom('albums')
+            .selectAll('albums')
+            .whereRef('albums.id', '=', 'shared_links.albumId')
+            .where('albums.deletedAt', 'is', null)
+            .leftJoin('albums_assets_assets', 'albums_assets_assets.albumsId', 'albums.id')
+            .leftJoinLateral(
+              (eb) =>
+                eb
+                  .selectFrom('assets')
+                  .selectAll('assets')
+                  .whereRef('albums_assets_assets.assetsId', '=', 'assets.id')
+                  .where('assets.deletedAt', 'is', null)
+                  .innerJoinLateral(
+                    (eb) =>
+                      eb
+                        .selectFrom('exif')
+                        .selectAll('exif')
+                        .whereRef('exif.assetId', '=', 'assets.id')
+                        .as('assets_exifInfo'),
+                    (join) => join.onTrue(),
+                  )
+                  .select((eb) => eb.fn.toJson(eb.table('assets_exifInfo')).as('exifInfo'))
+                  .orderBy('assets.fileCreatedAt', 'asc')
+                  .as('assets'),
+              (join) => join.onTrue(),
+            )
+            .innerJoinLateral(
+              (eb) =>
+                eb
+                  .selectFrom('users')
+                  .selectAll('users')
+                  .whereRef('users.id', '=', 'albums.ownerId')
+                  .where('users.deletedAt', 'is', null)
+                  .as('owner'),
+              (join) => join.onTrue(),
+            )
+            .select((eb) =>
+              eb.fn.coalesce(eb.fn.jsonAgg('assets').filterWhere('assets.id', 'is not', null), sql`'[]'`).as('assets'),
+            )
+            .select((eb) => eb.fn.toJson('owner').as('owner'))
+            .groupBy(['albums.id', sql`"owner".*`])
+            .as('album'),
+        (join) => join.onTrue(),
+      )
+      .select((eb) =>
+        eb.fn
+          .coalesce(eb.fn.jsonAgg('a').filterWhere('a.id', 'is not', null), sql`'[]'`)
+          .$castTo<MapAsset[]>()
+          .as('assets'),
+      )
+      .groupBy(['shared_links.id', sql`"album".*`])
+      .select((eb) => eb.fn.toJson('album').$castTo<Album | null>().as('album'))
+      .where('shared_links.id', '=', id)
+      .where((eb) => eb.or([eb('shared_links.type', '=', SharedLinkType.INDIVIDUAL), eb('album.id', 'is not', null)]))
+      .orderBy('shared_links.createdAt', 'desc')
+      .executeTakeFirst();
+  }
+
   @GenerateSql({ params: [DummyValue.BUFFER] })
   async getByKey(key: Buffer) {
     return this.db
       .selectFrom('shared_links')
       .where('shared_links.key', '=', key)
       .leftJoin('albums', 'albums.id', 'shared_links.albumId')
-      .where('albums.deletedAt', 'is', null)
       .select((eb) => [
         ...columns.authSharedLink,
         jsonObjectFrom(
@@ -181,6 +263,7 @@ export class SharedLinkRepository {
         ).as('user'),
       ])
       .where((eb) => eb.or([eb('shared_links.type', '=', SharedLinkType.INDIVIDUAL), eb('albums.id', 'is not', null)]))
+      .where('albums.deletedAt', 'is', null)
       .executeTakeFirst();
   }
 
@@ -248,7 +331,45 @@ export class SharedLinkRepository {
           .$castTo<MapAsset[]>()
           .as('assets'),
       )
-      .groupBy('shared_links.id')
+      .leftJoinLateral(
+        (eb) =>
+          eb
+            .selectFrom('albums')
+            .selectAll('albums')
+            .whereRef('albums.id', '=', 'shared_links.albumId')
+            .innerJoinLateral(
+              (eb) =>
+                eb
+                  .selectFrom('users')
+                  .select([
+                    'users.id',
+                    'users.email',
+                    'users.createdAt',
+                    'users.profileImagePath',
+                    'users.isAdmin',
+                    'users.shouldChangePassword',
+                    'users.deletedAt',
+                    'users.oauthId',
+                    'users.updatedAt',
+                    'users.storageLabel',
+                    'users.name',
+                    'users.quotaSizeInBytes',
+                    'users.quotaUsageInBytes',
+                    'users.status',
+                    'users.profileChangedAt',
+                  ])
+                  .whereRef('users.id', '=', 'albums.ownerId')
+                  .where('users.deletedAt', 'is', null)
+                  .as('owner'),
+              (join) => join.onTrue(),
+            )
+            .select((eb) => eb.fn.toJson('owner').as('owner'))
+            .where('albums.deletedAt', 'is', null)
+            .as('album'),
+        (join) => join.onTrue(),
+      )
+      .select((eb) => eb.fn.toJson('album').$castTo<Album | null>().as('album'))
+      .groupBy(['shared_links.id', sql`"album".*`])
       .executeTakeFirstOrThrow();
   }
 }
diff --git a/server/src/repositories/sync.repository.ts b/server/src/repositories/sync.repository.ts
index 699aaec83..2a7a55e3c 100644
--- a/server/src/repositories/sync.repository.ts
+++ b/server/src/repositories/sync.repository.ts
@@ -3,8 +3,11 @@ import { Kysely, SelectQueryBuilder, sql } from 'kysely';
 import { InjectKysely } from 'nestjs-kysely';
 import { columns } from 'src/database';
 import { DummyValue, GenerateSql } from 'src/decorators';
+import { AlbumRepository } from 'src/repositories/album.repository';
+import { SearchRepository } from 'src/repositories/search.repository';
 import { DB } from 'src/schema';
 import { SyncAck } from 'src/types';
+import { FilterUtil } from 'src/utils/filter.util';
 
 type AuditTables =
   | 'users_audit'
@@ -45,11 +48,15 @@ export class SyncRepository {
   stack: StackSync;
   user: UserSync;
 
-  constructor(@InjectKysely() private db: Kysely<DB>) {
+  constructor(
+    @InjectKysely() private db: Kysely<DB>,
+    private searchRepository: SearchRepository,
+    private albumRepository: AlbumRepository,
+  ) {
     this.album = new AlbumSync(this.db);
-    this.albumAsset = new AlbumAssetSync(this.db);
-    this.albumAssetExif = new AlbumAssetExifSync(this.db);
-    this.albumToAsset = new AlbumToAssetSync(this.db);
+    this.albumAsset = new AlbumAssetSync(this.db, this.searchRepository, this.albumRepository);
+    this.albumAssetExif = new AlbumAssetExifSync(this.db, this.searchRepository, this.albumRepository);
+    this.albumToAsset = new AlbumToAssetSync(this.db, this.searchRepository, this.albumRepository);
     this.albumUser = new AlbumUserSync(this.db);
     this.asset = new AssetSync(this.db);
     this.assetExif = new AssetExifSync(this.db);
@@ -140,8 +147,30 @@ class AlbumSync extends BaseSync {
 }
 
 class AlbumAssetSync extends BaseSync {
+  constructor(
+    protected db: Kysely<DB>,
+    private searchRepository: SearchRepository,
+    private albumRepository: AlbumRepository,
+  ) {
+    super(db);
+  }
+
   @GenerateSql({ params: [DummyValue.UUID, DummyValue.UUID, DummyValue.UUID], stream: true })
   getBackfill(albumId: string, afterUpdateId: string | undefined, beforeUpdateId: string) {
+    // Note: For dynamic albums, we need to do async operations, so we'll wrap this
+    return this.getBackfillInternal(albumId, afterUpdateId, beforeUpdateId);
+  }
+
+  private async getBackfillInternal(albumId: string, afterUpdateId: string | undefined, beforeUpdateId: string) {
+    // Check if this is a dynamic album
+    const album = await this.albumRepository.getById(albumId, { withAssets: false });
+
+    if (album?.dynamic && album.filters) {
+      // For dynamic albums, use search functionality to get assets
+      return this.getDynamicAlbumAssetsForBackfill(album, afterUpdateId, beforeUpdateId);
+    }
+
+    // For regular albums, use the existing logic
     return this.db
       .selectFrom('assets')
       .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'assets.id')
@@ -155,26 +184,155 @@ class AlbumAssetSync extends BaseSync {
       .stream();
   }
 
+  private async getDynamicAlbumAssetsForBackfill(
+    album: any,
+    afterUpdateId: string | undefined,
+    beforeUpdateId: string,
+  ) {
+    // Convert album filters to search options
+    const searchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, album.ownerId);
+
+    // Get assets that match the dynamic album filters
+    const searchResult = await this.searchRepository.searchMetadata(
+      { page: 1, size: 50000 }, // Large page size to get all matching assets
+      { ...searchOptions, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+    );
+
+    // Filter assets by updateId range and convert to sync format
+    const filteredAssets = searchResult.items
+      .filter((asset: any) => {
+        const updateId = asset.updateId;
+        const afterCondition = !afterUpdateId || updateId >= afterUpdateId;
+        const beforeCondition = updateId <= beforeUpdateId;
+        return afterCondition && beforeCondition;
+      })
+      .map((asset: any) => ({
+        ...asset,
+        updateId: asset.updateId,
+      }))
+      .sort((a: any, b: any) => a.updateId.localeCompare(b.updateId));
+
+    // Convert to async generator to match the stream interface
+    async function* streamAssets() {
+      for (const asset of filteredAssets) {
+        yield asset;
+      }
+    }
+
+    return streamAssets();
+  }
+
   @GenerateSql({ params: [DummyValue.UUID], stream: true })
   getUpserts(userId: string, ack?: SyncAck) {
-    return this.db
-      .selectFrom('assets')
-      .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'assets.id')
-      .select(columns.syncAsset)
-      .select('assets.updateId')
-      .where('assets.updatedAt', '<', sql.raw<Date>("now() - interval '1 millisecond'"))
-      .$if(!!ack, (qb) => qb.where('assets.updateId', '>', ack!.updateId))
-      .orderBy('assets.updateId', 'asc')
-      .innerJoin('albums', 'albums.id', 'album_assets.albumsId')
-      .leftJoin('albums_shared_users_users as album_users', 'album_users.albumsId', 'album_assets.albumsId')
-      .where((eb) => eb.or([eb('albums.ownerId', '=', userId), eb('album_users.usersId', '=', userId)]))
-      .stream();
+    // Note: For dynamic albums, we need to do async operations, so we'll wrap this
+    return this.getUpsertsInternal(userId, ack);
+  }
+
+  private async getUpsertsInternal(userId: string, ack?: SyncAck) {
+    // First, get all albums this user has access to and separate regular from dynamic
+    const [ownedAlbums, sharedAlbums] = await Promise.all([
+      this.albumRepository.getOwned(userId),
+      this.albumRepository.getShared(userId),
+    ]);
+
+    const allAlbums = [...ownedAlbums, ...sharedAlbums];
+    const regularAlbums = allAlbums.filter((album) => !album.dynamic);
+    const dynamicAlbums = allAlbums.filter((album) => album.dynamic);
+
+    // Get assets from regular albums using the existing logic
+    const regularAlbumIds = regularAlbums.map((album) => album.id);
+    let regularAssetsStream: any = undefined;
+    if (regularAlbumIds.length > 0) {
+      regularAssetsStream = this.db
+        .selectFrom('assets')
+        .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'assets.id')
+        .select(columns.syncAsset)
+        .select('assets.updateId')
+        .where('assets.updatedAt', '<', sql.raw<Date>("now() - interval '1 millisecond'"))
+        .$if(!!ack, (qb) => qb.where('assets.updateId', '>', ack!.updateId))
+        .orderBy('assets.updateId', 'asc')
+        .innerJoin('albums', 'albums.id', 'album_assets.albumsId')
+        .leftJoin('albums_shared_users_users as album_users', 'album_users.albumsId', 'album_assets.albumsId')
+        .where((eb) => eb.or([eb('albums.ownerId', '=', userId), eb('album_users.usersId', '=', userId)]))
+        .where('albums.dynamic', '=', false) // Only regular albums
+        .stream();
+    }
+
+    // Get assets from dynamic albums
+    const dynamicAssetsArrays = await Promise.all(
+      dynamicAlbums.map(async (album) => {
+        if (!album.filters) return [];
+
+        try {
+          const searchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, album.ownerId);
+          const searchResult = await this.searchRepository.searchMetadata(
+            { page: 1, size: 50000 },
+            { ...searchOptions, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+          );
+
+          return searchResult.items
+            .filter((asset: any) => {
+              const updateCondition = !ack || asset.updateId > ack.updateId;
+              const timeCondition = new Date(asset.updatedAt) < new Date(Date.now() - 1000); // 1 second ago
+              return updateCondition && timeCondition;
+            })
+            .map((asset: any) => ({
+              ...asset,
+              updateId: asset.updateId,
+            }));
+        } catch (error) {
+          console.error(`Failed to get dynamic album assets for album ${album.id}:`, error);
+          return [];
+        }
+      }),
+    );
+
+    // Flatten and sort dynamic assets
+    const dynamicAssets = dynamicAssetsArrays.flat().sort((a: any, b: any) => a.updateId.localeCompare(b.updateId));
+
+    // Combine regular and dynamic assets streams
+    async function* combinedStream() {
+      // Yield regular assets
+      if (regularAssetsStream) {
+        for await (const asset of regularAssetsStream) {
+          yield asset;
+        }
+      }
+
+      // Yield dynamic assets
+      for (const asset of dynamicAssets) {
+        yield asset;
+      }
+    }
+
+    return combinedStream();
   }
 }
 
 class AlbumAssetExifSync extends BaseSync {
+  constructor(
+    protected db: Kysely<DB>,
+    private searchRepository: SearchRepository,
+    private albumRepository: AlbumRepository,
+  ) {
+    super(db);
+  }
+
   @GenerateSql({ params: [DummyValue.UUID, DummyValue.UUID, DummyValue.UUID], stream: true })
   getBackfill(albumId: string, afterUpdateId: string | undefined, beforeUpdateId: string) {
+    return this.getBackfillInternal(albumId, afterUpdateId, beforeUpdateId);
+  }
+
+  private async getBackfillInternal(albumId: string, afterUpdateId: string | undefined, beforeUpdateId: string) {
+    // Check if this is a dynamic album
+    const album = await this.albumRepository.getById(albumId, { withAssets: false });
+
+    if (album?.dynamic && album.filters) {
+      // For dynamic albums, use search functionality to get asset exif data
+      return this.getDynamicAlbumAssetExifForBackfill(album, afterUpdateId, beforeUpdateId);
+    }
+
+    // For regular albums, use the existing logic
     return this.db
       .selectFrom('exif')
       .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'exif.assetId')
@@ -188,26 +346,164 @@ class AlbumAssetExifSync extends BaseSync {
       .stream();
   }
 
-  @GenerateSql({ params: [DummyValue.UUID], stream: true })
-  getUpserts(userId: string, ack?: SyncAck) {
-    return this.db
+  private async getDynamicAlbumAssetExifForBackfill(
+    album: any,
+    afterUpdateId: string | undefined,
+    beforeUpdateId: string,
+  ) {
+    // Convert album filters to search options
+    const searchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, album.ownerId);
+
+    // Get assets that match the dynamic album filters
+    const searchResult = await this.searchRepository.searchMetadata(
+      { page: 1, size: 50000 },
+      { ...searchOptions, withExif: true, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+    );
+
+    // Get exif data for matching assets and filter by updateId range
+    const assetIds = searchResult.items.map((asset: any) => asset.id);
+    if (assetIds.length === 0) {
+      async function* emptyStream() {}
+      return emptyStream();
+    }
+
+    // Query exif data for the assets
+    const exifData = await this.db
       .selectFrom('exif')
-      .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'exif.assetId')
       .select(columns.syncAssetExif)
       .select('exif.updateId')
+      .where('exif.assetId', 'in', assetIds)
       .where('exif.updatedAt', '<', sql.raw<Date>("now() - interval '1 millisecond'"))
-      .$if(!!ack, (qb) => qb.where('exif.updateId', '>', ack!.updateId))
+      .where('exif.updateId', '<=', beforeUpdateId)
+      .$if(!!afterUpdateId, (eb) => eb.where('exif.updateId', '>=', afterUpdateId!))
       .orderBy('exif.updateId', 'asc')
-      .innerJoin('albums', 'albums.id', 'album_assets.albumsId')
-      .leftJoin('albums_shared_users_users as album_users', 'album_users.albumsId', 'album_assets.albumsId')
-      .where((eb) => eb.or([eb('albums.ownerId', '=', userId), eb('album_users.usersId', '=', userId)]))
-      .stream();
+      .execute();
+
+    // Convert to async generator to match the stream interface
+    async function* streamExifData() {
+      for (const exif of exifData) {
+        yield exif;
+      }
+    }
+
+    return streamExifData();
+  }
+
+  @GenerateSql({ params: [DummyValue.UUID], stream: true })
+  getUpserts(userId: string, ack?: SyncAck) {
+    return this.getUpsertsInternal(userId, ack);
+  }
+
+  private async getUpsertsInternal(userId: string, ack?: SyncAck) {
+    // First, get all albums this user has access to and separate regular from dynamic
+    const [ownedAlbums, sharedAlbums] = await Promise.all([
+      this.albumRepository.getOwned(userId),
+      this.albumRepository.getShared(userId),
+    ]);
+
+    const allAlbums = [...ownedAlbums, ...sharedAlbums];
+    const regularAlbums = allAlbums.filter((album) => !album.dynamic);
+    const dynamicAlbums = allAlbums.filter((album) => album.dynamic);
+
+    // Get exif data from regular albums using the existing logic
+    const regularAlbumIds = regularAlbums.map((album) => album.id);
+    let regularExifStream: any = undefined;
+    if (regularAlbumIds.length > 0) {
+      regularExifStream = this.db
+        .selectFrom('exif')
+        .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'exif.assetId')
+        .select(columns.syncAssetExif)
+        .select('exif.updateId')
+        .where('exif.updatedAt', '<', sql.raw<Date>("now() - interval '1 millisecond'"))
+        .$if(!!ack, (qb) => qb.where('exif.updateId', '>', ack!.updateId))
+        .orderBy('exif.updateId', 'asc')
+        .innerJoin('albums', 'albums.id', 'album_assets.albumsId')
+        .leftJoin('albums_shared_users_users as album_users', 'album_users.albumsId', 'album_assets.albumsId')
+        .where((eb) => eb.or([eb('albums.ownerId', '=', userId), eb('album_users.usersId', '=', userId)]))
+        .where('albums.dynamic', '=', false) // Only regular albums
+        .stream();
+    }
+
+    // Get exif data from dynamic albums
+    const dynamicExifArrays = await Promise.all(
+      dynamicAlbums.map(async (album) => {
+        if (!album.filters) return [];
+
+        try {
+          const searchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, album.ownerId);
+          const searchResult = await this.searchRepository.searchMetadata(
+            { page: 1, size: 50000 },
+            { ...searchOptions, withExif: true, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+          );
+
+          const assetIds = searchResult.items.map((asset: any) => asset.id);
+          if (assetIds.length === 0) return [];
+
+          // Query exif data for these assets
+          const exifData = await this.db
+            .selectFrom('exif')
+            .select(columns.syncAssetExif)
+            .select('exif.updateId')
+            .where('exif.assetId', 'in', assetIds)
+            .where('exif.updatedAt', '<', sql.raw<Date>("now() - interval '1 millisecond'"))
+            .$if(!!ack, (qb) => qb.where('exif.updateId', '>', ack!.updateId))
+            .orderBy('exif.updateId', 'asc')
+            .execute();
+
+          return exifData;
+        } catch (error) {
+          console.error(`Failed to get dynamic album exif data for album ${album.id}:`, error);
+          return [];
+        }
+      }),
+    );
+
+    // Flatten and sort dynamic exif data
+    const dynamicExifData = dynamicExifArrays.flat().sort((a: any, b: any) => a.updateId.localeCompare(b.updateId));
+
+    // Combine regular and dynamic exif streams
+    async function* combinedStream() {
+      // Yield regular exif data
+      if (regularExifStream) {
+        for await (const exif of regularExifStream) {
+          yield exif;
+        }
+      }
+
+      // Yield dynamic exif data
+      for (const exif of dynamicExifData) {
+        yield exif;
+      }
+    }
+
+    return combinedStream();
   }
 }
 
 class AlbumToAssetSync extends BaseSync {
+  constructor(
+    protected db: Kysely<DB>,
+    private searchRepository: SearchRepository,
+    private albumRepository: AlbumRepository,
+  ) {
+    super(db);
+  }
+
   @GenerateSql({ params: [DummyValue.UUID, DummyValue.UUID, DummyValue.UUID], stream: true })
   getBackfill(albumId: string, afterUpdateId: string | undefined, beforeUpdateId: string) {
+    return this.getBackfillInternal(albumId, afterUpdateId, beforeUpdateId);
+  }
+
+  private async getBackfillInternal(albumId: string, afterUpdateId: string | undefined, beforeUpdateId: string) {
+    // Check if this is a dynamic album
+    const album = await this.albumRepository.getById(albumId, { withAssets: false });
+
+    if (album?.dynamic && album.filters) {
+      // For dynamic albums, create virtual album-to-asset relationships
+      return this.getDynamicAlbumToAssetBackfill(album, afterUpdateId, beforeUpdateId);
+    }
+
+    // For regular albums, use the existing logic
     return this.db
       .selectFrom('albums_assets_assets as album_assets')
       .select(['album_assets.assetsId as assetId', 'album_assets.albumsId as albumId', 'album_assets.updateId'])
@@ -219,6 +515,41 @@ class AlbumToAssetSync extends BaseSync {
       .stream();
   }
 
+  private async getDynamicAlbumToAssetBackfill(album: any, afterUpdateId: string | undefined, beforeUpdateId: string) {
+    // Convert album filters to search options
+    const searchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, album.ownerId);
+
+    // Get assets that match the dynamic album filters
+    const searchResult = await this.searchRepository.searchMetadata(
+      { page: 1, size: 50000 },
+      { ...searchOptions, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+    );
+
+    // Create virtual album-to-asset relationships
+    const relationships = searchResult.items
+      .filter((asset: any) => {
+        const updateId = asset.updateId;
+        const afterCondition = !afterUpdateId || updateId >= afterUpdateId;
+        const beforeCondition = updateId <= beforeUpdateId;
+        return afterCondition && beforeCondition;
+      })
+      .map((asset: any) => ({
+        assetId: asset.id,
+        albumId: album.id,
+        updateId: asset.updateId, // Use asset's updateId since there's no album_assets entry
+      }))
+      .sort((a: any, b: any) => a.updateId.localeCompare(b.updateId));
+
+    // Convert to async generator to match the stream interface
+    async function* streamRelationships() {
+      for (const relationship of relationships) {
+        yield relationship;
+      }
+    }
+
+    return streamRelationships();
+  }
+
   @GenerateSql({ params: [DummyValue.UUID], stream: true })
   getDeletes(userId: string, ack?: SyncAck) {
     return this.db
@@ -248,16 +579,88 @@ class AlbumToAssetSync extends BaseSync {
 
   @GenerateSql({ params: [DummyValue.UUID], stream: true })
   getUpserts(userId: string, ack?: SyncAck) {
-    return this.db
-      .selectFrom('albums_assets_assets as album_assets')
-      .select(['album_assets.assetsId as assetId', 'album_assets.albumsId as albumId', 'album_assets.updateId'])
-      .where('album_assets.updatedAt', '<', sql.raw<Date>("now() - interval '1 millisecond'"))
-      .$if(!!ack, (qb) => qb.where('album_assets.updateId', '>', ack!.updateId))
-      .orderBy('album_assets.updateId', 'asc')
-      .innerJoin('albums', 'albums.id', 'album_assets.albumsId')
-      .leftJoin('albums_shared_users_users as album_users', 'album_users.albumsId', 'album_assets.albumsId')
-      .where((eb) => eb.or([eb('albums.ownerId', '=', userId), eb('album_users.usersId', '=', userId)]))
-      .stream();
+    return this.getUpsertsInternal(userId, ack);
+  }
+
+  private async getUpsertsInternal(userId: string, ack?: SyncAck) {
+    // First, get all albums this user has access to and separate regular from dynamic
+    const [ownedAlbums, sharedAlbums] = await Promise.all([
+      this.albumRepository.getOwned(userId),
+      this.albumRepository.getShared(userId),
+    ]);
+
+    const allAlbums = [...ownedAlbums, ...sharedAlbums];
+    const regularAlbums = allAlbums.filter((album) => !album.dynamic);
+    const dynamicAlbums = allAlbums.filter((album) => album.dynamic);
+
+    // Get album-to-asset relationships from regular albums using the existing logic
+    const regularAlbumIds = regularAlbums.map((album) => album.id);
+    let regularRelationshipsStream: any = undefined;
+    if (regularAlbumIds.length > 0) {
+      regularRelationshipsStream = this.db
+        .selectFrom('albums_assets_assets as album_assets')
+        .select(['album_assets.assetsId as assetId', 'album_assets.albumsId as albumId', 'album_assets.updateId'])
+        .where('album_assets.updatedAt', '<', sql.raw<Date>("now() - interval '1 millisecond'"))
+        .$if(!!ack, (qb) => qb.where('album_assets.updateId', '>', ack!.updateId))
+        .orderBy('album_assets.updateId', 'asc')
+        .innerJoin('albums', 'albums.id', 'album_assets.albumsId')
+        .leftJoin('albums_shared_users_users as album_users', 'album_users.albumsId', 'album_assets.albumsId')
+        .where((eb) => eb.or([eb('albums.ownerId', '=', userId), eb('album_users.usersId', '=', userId)]))
+        .where('albums.dynamic', '=', false) // Only regular albums
+        .stream();
+    }
+
+    // Get virtual album-to-asset relationships from dynamic albums
+    const dynamicRelationshipsArrays = await Promise.all(
+      dynamicAlbums.map(async (album) => {
+        if (!album.filters) return [];
+
+        try {
+          const searchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, album.ownerId);
+          const searchResult = await this.searchRepository.searchMetadata(
+            { page: 1, size: 50000 },
+            { ...searchOptions, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+          );
+
+          return searchResult.items
+            .filter((asset: any) => {
+              const updateCondition = !ack || asset.updateId > ack.updateId;
+              const timeCondition = new Date(asset.updatedAt) < new Date(Date.now() - 1000); // 1 second ago
+              return updateCondition && timeCondition;
+            })
+            .map((asset: any) => ({
+              assetId: asset.id,
+              albumId: album.id,
+              updateId: asset.updateId, // Use asset's updateId since there's no album_assets entry
+            }));
+        } catch (error) {
+          console.error(`Failed to get dynamic album relationships for album ${album.id}:`, error);
+          return [];
+        }
+      }),
+    );
+
+    // Flatten and sort dynamic relationships
+    const dynamicRelationships = dynamicRelationshipsArrays
+      .flat()
+      .sort((a: any, b: any) => a.updateId.localeCompare(b.updateId));
+
+    // Combine regular and dynamic relationship streams
+    async function* combinedStream() {
+      // Yield regular relationships
+      if (regularRelationshipsStream) {
+        for await (const relationship of regularRelationshipsStream) {
+          yield relationship;
+        }
+      }
+
+      // Yield dynamic relationships
+      for (const relationship of dynamicRelationships) {
+        yield relationship;
+      }
+    }
+
+    return combinedStream();
   }
 }
 
diff --git a/server/src/schema/migrations/1752487436191-DynamicAlbums.ts b/server/src/schema/migrations/1752487436191-DynamicAlbums.ts
new file mode 100644
index 000000000..5d2931986
--- /dev/null
+++ b/server/src/schema/migrations/1752487436191-DynamicAlbums.ts
@@ -0,0 +1,34 @@
+import { Kysely, sql } from 'kysely';
+
+export async function up(db: Kysely<any>): Promise<void> {
+  // Add dynamic boolean field to albums table
+  await sql`
+    ALTER TABLE albums 
+    ADD COLUMN dynamic boolean DEFAULT false NOT NULL
+  `.execute(db);
+
+  // Add filters JSONB field to albums table
+  await sql`
+    ALTER TABLE albums 
+    ADD COLUMN filters jsonb DEFAULT null
+  `.execute(db);
+
+  // Create indexes for performance
+  await sql`
+    CREATE INDEX IDX_albums_dynamic ON albums(dynamic)
+  `.execute(db);
+
+  await sql`
+    CREATE INDEX IDX_albums_filters ON albums USING gin(filters)
+  `.execute(db);
+}
+
+export async function down(db: Kysely<any>): Promise<void> {
+  // Remove indexes
+  await sql`DROP INDEX IF EXISTS IDX_albums_dynamic`.execute(db);
+  await sql`DROP INDEX IF EXISTS IDX_albums_filters`.execute(db);
+
+  // Remove columns
+  await sql`ALTER TABLE albums DROP COLUMN IF EXISTS filters`.execute(db);
+  await sql`ALTER TABLE albums DROP COLUMN IF EXISTS dynamic`.execute(db);
+}
diff --git a/server/src/schema/tables/album.table.ts b/server/src/schema/tables/album.table.ts
index e4cad8f46..10954317d 100644
--- a/server/src/schema/tables/album.table.ts
+++ b/server/src/schema/tables/album.table.ts
@@ -60,6 +60,12 @@ export class AlbumTable {
   @Column({ default: AssetOrder.DESC })
   order!: Generated<AssetOrder>;
 
+  @Column({ type: 'boolean', default: false })
+  dynamic!: Generated<boolean>;
+
+  @Column({ type: 'jsonb', nullable: true })
+  filters!: object | null;
+
   @UpdateIdColumn({ indexName: 'IDX_albums_update_id' })
   updateId!: Generated<string>;
 }
diff --git a/server/src/services/album.service.ts b/server/src/services/album.service.ts
index e49d4bc5f..24fb20894 100644
--- a/server/src/services/album.service.ts
+++ b/server/src/services/album.service.ts
@@ -19,6 +19,7 @@ import { Permission } from 'src/enum';
 import { AlbumAssetCount, AlbumInfoOptions } from 'src/repositories/album.repository';
 import { BaseService } from 'src/services/base.service';
 import { addAssets, removeAssets } from 'src/utils/asset.util';
+import { FilterUtil } from 'src/utils/filter.util';
 import { getPreferences } from 'src/utils/preferences';
 
 @Injectable()
@@ -51,14 +52,91 @@ export class AlbumService extends BaseService {
       albums = await this.albumRepository.getOwned(ownerId);
     }
 
-    // Get asset count for each album. Then map the result to an object:
-    // { [albumId]: assetCount }
-    const results = await this.albumRepository.getMetadataForIds(albums.map((album) => album.id));
+    // Separate regular and dynamic albums
+    const regularAlbums = albums.filter((album) => !album.dynamic);
+    const dynamicAlbums = albums.filter((album) => album.dynamic);
+
+    // Get asset count for regular albums using the repository
+    const regularAlbumIds = regularAlbums.map((album) => album.id);
+    const results = regularAlbumIds.length > 0 ? await this.albumRepository.getMetadataForIds(regularAlbumIds) : [];
     const albumMetadata: Record<string, AlbumAssetCount> = {};
     for (const metadata of results) {
       albumMetadata[metadata.albumId] = metadata;
     }
 
+    // Calculate metadata for dynamic albums using search
+    for (const dynamicAlbum of dynamicAlbums) {
+      if (dynamicAlbum.filters) {
+        try {
+          const searchOptions = FilterUtil.convertFiltersToSearchOptions(dynamicAlbum.filters, ownerId);
+          const searchResult = await this.searchRepository.searchMetadata(
+            { page: 1, size: 50000 }, // Large page size to get all matching assets
+            { ...searchOptions, orderDirection: dynamicAlbum.order === 'asc' ? 'asc' : 'desc' },
+          );
+
+          const assets = searchResult.items;
+
+          if (assets.length > 0) {
+            const dates = assets
+              .map((asset: any) => asset.fileCreatedAt || asset.localDateTime)
+              .filter(Boolean)
+              .map((date: any) => new Date(date))
+              .sort((a: Date, b: Date) => a.getTime() - b.getTime());
+
+            const updatedDates = assets
+              .map((asset: any) => asset.updatedAt)
+              .filter(Boolean)
+              .map((date: any) => new Date(date))
+              .sort((a: Date, b: Date) => b.getTime() - a.getTime());
+
+            // For dynamic albums, assign thumbnail from the first asset if no thumbnail is set
+            if (!dynamicAlbum.albumThumbnailAssetId && assets.length > 0) {
+              const thumbnailAssetId = assets[0].id;
+              await this.albumRepository.update(dynamicAlbum.id, {
+                id: dynamicAlbum.id,
+                albumThumbnailAssetId: thumbnailAssetId,
+              });
+              dynamicAlbum.albumThumbnailAssetId = thumbnailAssetId;
+            }
+
+            albumMetadata[dynamicAlbum.id] = {
+              albumId: dynamicAlbum.id,
+              assetCount: assets.length,
+              startDate: dates.length > 0 ? dates[0] : null,
+              endDate: dates.length > 0 ? dates[dates.length - 1] : null,
+              lastModifiedAssetTimestamp: updatedDates.length > 0 ? updatedDates[0] : null,
+            };
+          } else {
+            albumMetadata[dynamicAlbum.id] = {
+              albumId: dynamicAlbum.id,
+              assetCount: 0,
+              startDate: null,
+              endDate: null,
+              lastModifiedAssetTimestamp: null,
+            };
+          }
+        } catch (error) {
+          // If search fails, use empty metadata
+          albumMetadata[dynamicAlbum.id] = {
+            albumId: dynamicAlbum.id,
+            assetCount: 0,
+            startDate: null,
+            endDate: null,
+            lastModifiedAssetTimestamp: null,
+          };
+        }
+      } else {
+        // No filters, so no assets
+        albumMetadata[dynamicAlbum.id] = {
+          albumId: dynamicAlbum.id,
+          assetCount: 0,
+          startDate: null,
+          endDate: null,
+          lastModifiedAssetTimestamp: null,
+        };
+      }
+    }
+
     return albums.map((album) => ({
       ...mapAlbumWithoutAssets(album),
       sharedLinks: undefined,
@@ -71,14 +149,78 @@ export class AlbumService extends BaseService {
   }
 
   async get(auth: AuthDto, id: string, dto: AlbumInfoDto): Promise<AlbumResponseDto> {
+    // throw new Error('Not implemented');
     await this.requireAccess({ auth, permission: Permission.ALBUM_READ, ids: [id] });
     await this.albumRepository.updateThumbnails();
     const withAssets = dto.withoutAssets === undefined ? true : !dto.withoutAssets;
-    const album = await this.findOrFail(id, { withAssets });
+    const album = await this.findOrFail(id, { withAssets: false }); // Always load without assets first
+
+    // Check if this is a dynamic album
+    if (album.dynamic && album.filters) {
+      // Convert album filters to search options for SearchRepository
+      const dynamicSearchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, auth.user.id);
+
+      // Always get the search result to calculate metadata, even if we don't need full assets
+      const searchResult = await this.searchRepository.searchMetadata(
+        { page: 1, size: 50000 }, // Large page size to get all matching assets
+        { ...dynamicSearchOptions, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+      );
+
+      const foundAssets = searchResult.items;
+
+      // For dynamic albums, calculate metadata from the actual search results
+      let startDate: Date | undefined;
+      let endDate: Date | undefined;
+      let lastModifiedAssetTimestamp: Date | undefined;
+
+      if (foundAssets.length > 0) {
+        const dates = foundAssets
+          .map((asset: any) => asset.fileCreatedAt || asset.localDateTime)
+          .filter(Boolean)
+          .map((date: any) => new Date(date))
+          .sort((a: Date, b: Date) => a.getTime() - b.getTime());
+
+        if (dates.length > 0) {
+          startDate = dates[0];
+          endDate = dates[dates.length - 1];
+        }
+
+        const updatedDates = foundAssets
+          .map((asset: any) => asset.updatedAt)
+          .filter(Boolean)
+          .map((date: any) => new Date(date))
+          .sort((a: Date, b: Date) => b.getTime() - a.getTime());
+
+        if (updatedDates.length > 0) {
+          lastModifiedAssetTimestamp = updatedDates[0];
+        }
+
+        // For dynamic albums, assign thumbnail from the first asset if no thumbnail is set
+        if (!album.albumThumbnailAssetId && foundAssets.length > 0) {
+          const thumbnailAssetId = foundAssets[0].id;
+          await this.albumRepository.update(album.id, {
+            id: album.id,
+            albumThumbnailAssetId: thumbnailAssetId,
+          });
+          album.albumThumbnailAssetId = thumbnailAssetId;
+        }
+      }
+
+      return {
+        ...mapAlbum({ ...album, assets: withAssets ? foundAssets : [] }, withAssets, auth),
+        startDate,
+        endDate,
+        assetCount: foundAssets.length,
+        lastModifiedAssetTimestamp,
+      };
+    }
+
+    // For regular albums, use the existing logic
+    const albumWithAssets = withAssets ? await this.findOrFail(id, { withAssets: true }) : album;
     const [albumMetadataForIds] = await this.albumRepository.getMetadataForIds([album.id]);
 
     return {
-      ...mapAlbum(album, withAssets, auth),
+      ...mapAlbum(albumWithAssets, withAssets, auth),
       startDate: albumMetadataForIds?.startDate ?? undefined,
       endDate: albumMetadataForIds?.endDate ?? undefined,
       assetCount: albumMetadataForIds?.assetCount ?? 0,
@@ -100,24 +242,51 @@ export class AlbumService extends BaseService {
       }
     }
 
-    const allowedAssetIdsSet = await this.checkAccess({
-      auth,
-      permission: Permission.ASSET_SHARE,
-      ids: dto.assetIds || [],
-    });
-    const assetIds = [...allowedAssetIdsSet].map((id) => id);
+    // For dynamic albums, we don't need to check asset access or add assets
+    let assetIds: string[] = [];
+    if (!dto.dynamic) {
+      const allowedAssetIdsSet = await this.checkAccess({
+        auth,
+        permission: Permission.ASSET_SHARE,
+        ids: dto.assetIds || [],
+      });
+      assetIds = [...allowedAssetIdsSet].map((id) => id);
+    }
 
     const userMetadata = await this.userRepository.getMetadata(auth.user.id);
 
+    // For dynamic albums, get the first asset that matches the filters to use as thumbnail
+    let dynamicAlbumThumbnailAssetId = null;
+    if (dto.dynamic && dto.filters) {
+      try {
+        const searchOptions = FilterUtil.convertFiltersToSearchOptions(dto.filters, auth.user.id);
+        const searchResult = await this.searchRepository.searchMetadata(
+          { page: 1, size: 1 }, // Just get the first asset
+          {
+            ...searchOptions,
+            orderDirection: getPreferences(userMetadata).albums.defaultAssetOrder === 'asc' ? 'asc' : 'desc',
+          },
+        );
+        if (searchResult.items.length > 0) {
+          dynamicAlbumThumbnailAssetId = searchResult.items[0].id;
+        }
+      } catch (error) {
+        // If search fails, continue without thumbnail
+        this.logger.warn(`Failed to get thumbnail for dynamic album: ${error}`);
+      }
+    }
+
     const album = await this.albumRepository.create(
       {
         ownerId: auth.user.id,
         albumName: dto.albumName,
         description: dto.description,
-        albumThumbnailAssetId: assetIds[0] || null,
+        albumThumbnailAssetId: dto.dynamic ? dynamicAlbumThumbnailAssetId : assetIds[0] || null,
         order: getPreferences(userMetadata).albums.defaultAssetOrder,
+        dynamic: dto.dynamic || false,
+        filters: dto.filters || null,
       },
-      assetIds,
+      dto.dynamic ? [] : assetIds, // Don't add assets for dynamic albums
       albumUsers,
     );
 
@@ -131,23 +300,69 @@ export class AlbumService extends BaseService {
   async update(auth: AuthDto, id: string, dto: UpdateAlbumDto): Promise<AlbumResponseDto> {
     await this.requireAccess({ auth, permission: Permission.ALBUM_UPDATE, ids: [id] });
 
-    const album = await this.findOrFail(id, { withAssets: true });
+    const album = await this.findOrFail(id, { withAssets: false });
 
     if (dto.albumThumbnailAssetId) {
-      const results = await this.albumRepository.getAssetIds(id, [dto.albumThumbnailAssetId]);
-      if (results.size === 0) {
-        throw new BadRequestException('Invalid album thumbnail');
+      // For regular albums, validate thumbnail asset exists in album
+      if (!album.dynamic) {
+        const results = await this.albumRepository.getAssetIds(id, [dto.albumThumbnailAssetId]);
+        if (results.size === 0) {
+          throw new BadRequestException('Invalid album thumbnail');
+        }
+      } else {
+        // For dynamic albums, validate thumbnail asset matches current filters
+        if (album.filters) {
+          const searchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, auth.user.id);
+          const searchResult = await this.searchRepository.searchMetadata(
+            { page: 1, size: 50000 },
+            { ...searchOptions, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+          );
+          const assetIds = searchResult.items.map((asset: any) => asset.id);
+          if (!assetIds.includes(dto.albumThumbnailAssetId)) {
+            throw new BadRequestException('Invalid album thumbnail - asset does not match album filters');
+          }
+        }
+      }
+    }
+
+    // For dynamic albums, handle thumbnail updates when filters change
+    let finalAlbumThumbnailAssetId = dto.albumThumbnailAssetId;
+
+    if (album.dynamic && dto.filters && JSON.stringify(dto.filters) !== JSON.stringify(album.filters)) {
+      // Filters have changed, check if current thumbnail is still valid
+      const searchOptions = FilterUtil.convertFiltersToSearchOptions(dto.filters, auth.user.id);
+      const searchResult = await this.searchRepository.searchMetadata(
+        { page: 1, size: 50000 },
+        { ...searchOptions, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+      );
+      const assetIds = searchResult.items.map((asset: any) => asset.id);
+
+      // If current thumbnail is no longer in the album, set it to the first asset
+      if (album.albumThumbnailAssetId && !assetIds.includes(album.albumThumbnailAssetId)) {
+        finalAlbumThumbnailAssetId = assetIds.length > 0 ? assetIds[0] : null;
+      } else if (!album.albumThumbnailAssetId && assetIds.length > 0) {
+        // If no thumbnail was set and we have assets, set the first one
+        finalAlbumThumbnailAssetId = assetIds[0];
       }
     }
+
     const updatedAlbum = await this.albumRepository.update(album.id, {
       id: album.id,
       albumName: dto.albumName,
       description: dto.description,
-      albumThumbnailAssetId: dto.albumThumbnailAssetId,
+      albumThumbnailAssetId: finalAlbumThumbnailAssetId,
       isActivityEnabled: dto.isActivityEnabled,
       order: dto.order,
+      dynamic: dto.dynamic ?? album.dynamic,
+      filters: dto.filters ?? album.filters,
     });
 
+    // For dynamic albums, return empty assets for now
+    // TODO: Implement proper dynamic album asset retrieval
+    if (updatedAlbum.dynamic) {
+      return mapAlbumWithoutAssets({ ...updatedAlbum, assets: [] });
+    }
+
     return mapAlbumWithoutAssets({ ...updatedAlbum, assets: album.assets });
   }
 
@@ -158,6 +373,14 @@ export class AlbumService extends BaseService {
 
   async addAssets(auth: AuthDto, id: string, dto: BulkIdsDto): Promise<BulkIdResponseDto[]> {
     const album = await this.findOrFail(id, { withAssets: false });
+
+    // Prevent adding assets to dynamic albums
+    if (album.dynamic) {
+      throw new BadRequestException(
+        'Cannot add assets to dynamic albums. Assets are automatically populated based on filters.',
+      );
+    }
+
     await this.requireAccess({ auth, permission: Permission.ALBUM_ADD_ASSET, ids: [id] });
 
     const results = await addAssets(
@@ -187,9 +410,17 @@ export class AlbumService extends BaseService {
   }
 
   async removeAssets(auth: AuthDto, id: string, dto: BulkIdsDto): Promise<BulkIdResponseDto[]> {
+    const album = await this.findOrFail(id, { withAssets: false });
+
+    // Prevent removing assets from dynamic albums
+    if (album.dynamic) {
+      throw new BadRequestException(
+        'Cannot remove assets from dynamic albums. Assets are automatically populated based on filters.',
+      );
+    }
+
     await this.requireAccess({ auth, permission: Permission.ALBUM_REMOVE_ASSET, ids: [id] });
 
-    const album = await this.findOrFail(id, { withAssets: false });
     const results = await removeAssets(
       auth,
       { access: this.accessRepository, bulk: this.albumRepository },
diff --git a/server/src/services/download.service.spec.ts b/server/src/services/download.service.spec.ts
index 764663709..0fe043930 100644
--- a/server/src/services/download.service.spec.ts
+++ b/server/src/services/download.service.spec.ts
@@ -255,7 +255,7 @@ describe(DownloadService.name, () => {
           { id: 'asset-2', livePhotoVideoId: 'asset-4', size: 100_000 },
         ]),
       );
-      mocks.downloadRepository.downloadMotionAssetIds.mockReturnValue(
+      mocks.downloadRepository.downloadAssetPaths.mockReturnValue(
         makeStream([
           { id: 'asset-3', livePhotoVideoId: null, size: 23_456, originalPath: '/path/to/file.mp4' },
           { id: 'asset-4', livePhotoVideoId: null, size: 123_000, originalPath: '/path/to/file.mp4' },
@@ -279,7 +279,7 @@ describe(DownloadService.name, () => {
       mocks.downloadRepository.downloadAssetIds.mockReturnValue(
         makeStream([{ id: 'asset-1', livePhotoVideoId: 'asset-3', size: 5000 }]),
       );
-      mocks.downloadRepository.downloadMotionAssetIds.mockReturnValue(
+      mocks.downloadRepository.downloadAssetPaths.mockReturnValue(
         makeStream([
           { id: 'asset-2', livePhotoVideoId: null, size: 23_456, originalPath: 'upload/encoded-video/uuid-MP.mp4' },
         ]),
diff --git a/server/src/services/download.service.ts b/server/src/services/download.service.ts
index 02711b9bf..418ab36af 100644
--- a/server/src/services/download.service.ts
+++ b/server/src/services/download.service.ts
@@ -22,7 +22,20 @@ export class DownloadService extends BaseService {
     } else if (dto.albumId) {
       const albumId = dto.albumId;
       await this.requireAccess({ auth, permission: Permission.ALBUM_DOWNLOAD, ids: [albumId] });
-      assets = this.downloadRepository.downloadAlbumId(albumId);
+
+      // Check if this is a dynamic album
+      const album = await this.albumRepository.getById(albumId, { withAssets: false });
+      if (!album) {
+        throw new BadRequestException('Album not found');
+      }
+
+      if (album.dynamic && album.filters) {
+        // For dynamic albums, use the search-based approach
+        assets = this.downloadRepository.downloadAlbumId(albumId, true, album.filters, auth.user.id);
+      } else {
+        // For regular albums, use the existing logic
+        assets = this.downloadRepository.downloadAlbumId(albumId);
+      }
     } else if (dto.userId) {
       const userId = dto.userId;
       await this.requireAccess({ auth, permission: Permission.TIMELINE_DOWNLOAD, ids: [userId] });
@@ -58,7 +71,7 @@ export class DownloadService extends BaseService {
     }
 
     if (motionIds.size > 0) {
-      const motionAssets = this.downloadRepository.downloadMotionAssetIds([...motionIds]);
+      const motionAssets = this.downloadRepository.downloadAssetPaths([...motionIds]);
       for await (const motionAsset of motionAssets) {
         if (StorageCore.isAndroidMotionPath(motionAsset.originalPath) && !preferences.download.includeEmbeddedVideos) {
           continue;
diff --git a/server/src/services/map.service.ts b/server/src/services/map.service.ts
index 94eca77a6..df267e3ce 100644
--- a/server/src/services/map.service.ts
+++ b/server/src/services/map.service.ts
@@ -3,6 +3,7 @@ import { AuthDto } from 'src/dtos/auth.dto';
 import { MapMarkerDto, MapMarkerResponseDto, MapReverseGeocodeDto } from 'src/dtos/map.dto';
 import { BaseService } from 'src/services/base.service';
 import { getMyPartnerIds } from 'src/utils/asset.util';
+import { FilterUtil } from 'src/utils/filter.util';
 
 @Injectable()
 export class MapService extends BaseService {
@@ -13,17 +14,93 @@ export class MapService extends BaseService {
       userIds.push(...partnerIds);
     }
 
-    // TODO convert to SQL join
-    const albumIds: string[] = [];
+    // Handle albums - separate regular and dynamic albums
+    const regularAlbumIds: string[] = [];
+    const dynamicAlbums: Array<{ id: string; filters: any; ownerId: string }> = [];
+
     if (options.withSharedAlbums) {
       const [ownedAlbums, sharedAlbums] = await Promise.all([
         this.albumRepository.getOwned(auth.user.id),
         this.albumRepository.getShared(auth.user.id),
       ]);
-      albumIds.push(...ownedAlbums.map((album) => album.id), ...sharedAlbums.map((album) => album.id));
+
+      // Separate regular and dynamic albums
+      for (const album of [...ownedAlbums, ...sharedAlbums]) {
+        if (album.dynamic && album.filters) {
+          dynamicAlbums.push({
+            id: album.id,
+            filters: album.filters,
+            ownerId: album.ownerId,
+          });
+        } else {
+          regularAlbumIds.push(album.id);
+        }
+      }
+    }
+
+    // Get map markers for regular albums
+    const regularAlbumMarkers = await this.mapRepository.getMapMarkers(userIds, regularAlbumIds, options);
+
+    // Get map markers for dynamic albums using search functionality
+    const dynamicAlbumMarkers = await this.getMapMarkersForDynamicAlbums(dynamicAlbums, options);
+
+    // Combine and return all markers
+    return [...regularAlbumMarkers, ...dynamicAlbumMarkers];
+  }
+
+  private async getMapMarkersForDynamicAlbums(
+    dynamicAlbums: Array<{ id: string; filters: any; ownerId: string }>,
+    options: MapMarkerDto,
+  ): Promise<MapMarkerResponseDto[]> {
+    if (dynamicAlbums.length === 0) {
+      return [];
+    }
+
+    const allMarkers: MapMarkerResponseDto[] = [];
+
+    for (const album of dynamicAlbums) {
+      try {
+        // Convert album filters to search options
+        const searchOptions = FilterUtil.convertFiltersToSearchOptions(album.filters, album.ownerId);
+
+        // Add map-specific options
+        const mapSearchOptions = {
+          ...searchOptions,
+          // Only include assets with GPS coordinates
+          withExif: true,
+          // Apply map-specific filters
+          isArchived: options.isArchived,
+          isFavorite: options.isFavorite,
+          fileCreatedAfter: options.fileCreatedAfter,
+          fileCreatedBefore: options.fileCreatedBefore,
+        };
+
+        // Get assets for this dynamic album using search
+        const searchResult = await this.searchRepository.searchMetadata(
+          { page: 1, size: 50000 }, // Large page size to get all matching assets
+          mapSearchOptions,
+        );
+
+        // Filter assets to only include those with GPS coordinates and convert to map markers
+        const markers = searchResult.items
+          .filter((asset: any) => asset.exif?.latitude && asset.exif?.longitude)
+          .map((asset: any) => ({
+            id: asset.id,
+            lat: asset.exif.latitude,
+            lon: asset.exif.longitude,
+            city: asset.exif.city || null,
+            state: asset.exif.state || null,
+            country: asset.exif.country || null,
+          }));
+
+        allMarkers.push(...markers);
+      } catch (error) {
+        this.logger.error(`Failed to get map markers for dynamic album ${album.id}`, error);
+        // Continue with other albums even if one fails
+      }
     }
 
-    return this.mapRepository.getMapMarkers(userIds, albumIds, options);
+    return allMarkers;
   }
 
   async reverseGeocode(dto: MapReverseGeocodeDto) {
diff --git a/server/src/services/shared-link.service.ts b/server/src/services/shared-link.service.ts
index c70b31a3a..c5c9ab774 100644
--- a/server/src/services/shared-link.service.ts
+++ b/server/src/services/shared-link.service.ts
@@ -1,6 +1,7 @@
 import { BadRequestException, ForbiddenException, Injectable, UnauthorizedException } from '@nestjs/common';
 import { SharedLink } from 'src/database';
 import { AssetIdErrorReason, AssetIdsResponseDto } from 'src/dtos/asset-ids.response.dto';
+import { mapAsset } from 'src/dtos/asset-response.dto';
 import { AssetIdsDto } from 'src/dtos/asset.dto';
 import { AuthDto } from 'src/dtos/auth.dto';
 import {
@@ -14,14 +15,14 @@ import {
 } from 'src/dtos/shared-link.dto';
 import { Permission, SharedLinkType } from 'src/enum';
 import { BaseService } from 'src/services/base.service';
+import { FilterUtil } from 'src/utils/filter.util';
 import { getExternalDomain, OpenGraphTags } from 'src/utils/misc';
 
 @Injectable()
 export class SharedLinkService extends BaseService {
   async getAll(auth: AuthDto, { albumId }: SharedLinkSearchDto): Promise<SharedLinkResponseDto[]> {
-    return this.sharedLinkRepository
-      .getAll({ userId: auth.user.id, albumId })
-      .then((links) => links.map((link) => mapSharedLink(link)));
+    const links = await this.sharedLinkRepository.getAll({ userId: auth.user.id, albumId });
+    return links.map((link) => mapSharedLink(link));
   }
 
   async getMine(auth: AuthDto, dto: SharedLinkPasswordDto): Promise<SharedLinkResponseDto> {
@@ -30,7 +31,7 @@ export class SharedLinkService extends BaseService {
     }
 
     const sharedLink = await this.findOrFail(auth.user.id, auth.sharedLink.id);
-    const response = this.mapToSharedLink(sharedLink, { withExif: sharedLink.showExif });
+    const response = await this.mapToSharedLink(sharedLink, { withExif: sharedLink.showExif });
     if (sharedLink.password) {
       response.token = this.validateAndRefreshToken(sharedLink, dto);
     }
@@ -40,7 +41,7 @@ export class SharedLinkService extends BaseService {
 
   async get(auth: AuthDto, id: string): Promise<SharedLinkResponseDto> {
     const sharedLink = await this.findOrFail(auth.user.id, id);
-    return this.mapToSharedLink(sharedLink, { withExif: true });
+    return await this.mapToSharedLink(sharedLink, { withExif: true });
   }
 
   async create(auth: AuthDto, dto: SharedLinkCreateDto): Promise<SharedLinkResponseDto> {
@@ -78,7 +79,7 @@ export class SharedLinkService extends BaseService {
       showExif: dto.showMetadata ?? true,
     });
 
-    return this.mapToSharedLink(sharedLink, { withExif: true });
+    return await this.mapToSharedLink(sharedLink, { withExif: true });
   }
 
   async update(auth: AuthDto, id: string, dto: SharedLinkEditDto) {
@@ -93,7 +94,7 @@ export class SharedLinkService extends BaseService {
       allowDownload: dto.allowDownload,
       showExif: dto.showMetadata,
     });
-    return this.mapToSharedLink(sharedLink, { withExif: true });
+    return await this.mapToSharedLink(sharedLink, { withExif: true });
   }
 
   async remove(auth: AuthDto, id: string): Promise<void> {
@@ -103,7 +104,9 @@ export class SharedLinkService extends BaseService {
 
   // TODO: replace `userId` with permissions and access control checks
   private async findOrFail(userId: string, id: string) {
-    const sharedLink = await this.sharedLinkRepository.get(userId, id);
+    // For shared links, we need to get the shared link by ID without user restriction
+    // since the user accessing it might not be the owner
+    const sharedLink = await this.sharedLinkRepository.getById(id);
     if (!sharedLink) {
       throw new BadRequestException('Shared link not found');
     }
@@ -117,7 +120,7 @@ export class SharedLinkService extends BaseService {
       throw new BadRequestException('Invalid shared link type');
     }
 
-    const existingAssetIds = new Set(sharedLink.assets.map((asset) => asset.id));
+    const existingAssetIds = new Set(sharedLink.assets.map((asset: any) => asset.id));
     const notPresentAssetIds = dto.assetIds.filter((assetId) => !existingAssetIds.has(assetId));
     const allowedAssetIds = await this.checkAccess({
       auth,
@@ -159,14 +162,14 @@ export class SharedLinkService extends BaseService {
 
     const results: AssetIdsResponseDto[] = [];
     for (const assetId of dto.assetIds) {
-      const hasAsset = sharedLink.assets.find((asset) => asset.id === assetId);
+      const hasAsset = sharedLink.assets.find((asset: any) => asset.id === assetId);
       if (!hasAsset) {
         results.push({ assetId, success: false, error: AssetIdErrorReason.NOT_FOUND });
         continue;
       }
 
       results.push({ assetId, success: true });
-      sharedLink.assets = sharedLink.assets.filter((asset) => asset.id !== assetId);
+      sharedLink.assets = sharedLink.assets.filter((asset: any) => asset.id !== assetId);
     }
 
     await this.sharedLinkRepository.update(sharedLink);
@@ -194,8 +197,39 @@ export class SharedLinkService extends BaseService {
     };
   }
 
-  private mapToSharedLink(sharedLink: SharedLink, { withExif }: { withExif: boolean }) {
-    return withExif ? mapSharedLink(sharedLink) : mapSharedLinkWithoutMetadata(sharedLink);
+  private async mapToSharedLink(sharedLink: SharedLink, { withExif }: { withExif: boolean }) {
+    const baseResponse = withExif ? mapSharedLink(sharedLink) : mapSharedLinkWithoutMetadata(sharedLink);
+
+    // Handle dynamic albums by fetching assets based on filters
+    if (sharedLink.album?.dynamic && sharedLink.album?.filters) {
+      try {
+        // Convert album filters to search options
+        // Use the album owner's ID for the search, not the shared link user's ID
+        const searchOptions = FilterUtil.convertFiltersToSearchOptions(
+          sharedLink.album.filters,
+          sharedLink.album.ownerId,
+        );
+
+        // Get assets based on filters
+        const searchResult = await this.searchRepository.searchMetadata(
+          { page: 1, size: 50000 }, // Large page size to get all matching assets
+          { ...searchOptions, orderDirection: sharedLink.album.order === 'asc' ? 'asc' : 'desc' },
+        );
+
+        // Update the response with the dynamic album assets
+        baseResponse.assets = searchResult.items.map((asset) => mapAsset(asset, { stripMetadata: !withExif }));
+
+        // Also update the album's asset count for metadata
+        if (baseResponse.album) {
+          baseResponse.album.assetCount = searchResult.items.length;
+        }
+      } catch (error) {
+        this.logger.error('Failed to fetch dynamic album assets for shared link', error);
+        // If search fails, keep the original assets (empty for dynamic albums)
+      }
+    }
+
+    return baseResponse;
   }
 
   private validateAndRefreshToken(sharedLink: SharedLink, dto: SharedLinkPasswordDto): string {
diff --git a/server/src/services/sync.service.ts b/server/src/services/sync.service.ts
index e3322de2e..bb55e72b4 100644
--- a/server/src/services/sync.service.ts
+++ b/server/src/services/sync.service.ts
@@ -372,7 +372,7 @@ export class SyncService extends BaseService {
         }
 
         const startId = getStartId(createId, backfillCheckpoint);
-        const backfill = this.syncRepository.albumAsset.getBackfill(album.id, startId, endId);
+        const backfill = await this.syncRepository.albumAsset.getBackfill(album.id, startId, endId);
 
         for await (const { updateId, ...data } of backfill) {
           send(response, { type: backfillType, ids: [createId, updateId], data: mapSyncAssetV1(data) });
@@ -388,7 +388,7 @@ export class SyncService extends BaseService {
       });
     }
 
-    const upserts = this.syncRepository.albumAsset.getUpserts(auth.user.id, checkpointMap[upsertType]);
+    const upserts = await this.syncRepository.albumAsset.getUpserts(auth.user.id, checkpointMap[upsertType]);
     for await (const { updateId, ...data } of upserts) {
       send(response, { type: upsertType, ids: [updateId], data: mapSyncAssetV1(data) });
     }
@@ -415,7 +415,7 @@ export class SyncService extends BaseService {
         }
 
         const startId = getStartId(createId, backfillCheckpoint);
-        const backfill = this.syncRepository.albumAssetExif.getBackfill(album.id, startId, endId);
+        const backfill = await this.syncRepository.albumAssetExif.getBackfill(album.id, startId, endId);
 
         for await (const { updateId, ...data } of backfill) {
           send(response, { type: backfillType, ids: [createId, updateId], data });
@@ -431,7 +431,7 @@ export class SyncService extends BaseService {
       });
     }
 
-    const upserts = this.syncRepository.albumAssetExif.getUpserts(auth.user.id, checkpointMap[upsertType]);
+    const upserts = await this.syncRepository.albumAssetExif.getUpserts(auth.user.id, checkpointMap[upsertType]);
     for await (const { updateId, ...data } of upserts) {
       send(response, { type: upsertType, ids: [updateId], data });
     }
@@ -464,7 +464,7 @@ export class SyncService extends BaseService {
         }
 
         const startId = getStartId(createId, backfillCheckpoint);
-        const backfill = this.syncRepository.albumToAsset.getBackfill(album.id, startId, endId);
+        const backfill = await this.syncRepository.albumToAsset.getBackfill(album.id, startId, endId);
 
         for await (const { updateId, ...data } of backfill) {
           send(response, { type: backfillType, ids: [createId, updateId], data });
@@ -480,7 +480,7 @@ export class SyncService extends BaseService {
       });
     }
 
-    const upserts = this.syncRepository.albumToAsset.getUpserts(auth.user.id, checkpointMap[upsertType]);
+    const upserts = await this.syncRepository.albumToAsset.getUpserts(auth.user.id, checkpointMap[upsertType]);
     for await (const { updateId, ...data } of upserts) {
       send(response, { type: upsertType, ids: [updateId], data });
     }
diff --git a/server/src/services/timeline.service.ts b/server/src/services/timeline.service.ts
index abd536a97..f9f565196 100644
--- a/server/src/services/timeline.service.ts
+++ b/server/src/services/timeline.service.ts
@@ -6,11 +6,23 @@ import { TimeBucketOptions } from 'src/repositories/asset.repository';
 import { BaseService } from 'src/services/base.service';
 import { requireElevatedPermission } from 'src/utils/access';
 import { getMyPartnerIds } from 'src/utils/asset.util';
+import { hexOrBufferToBase64 } from 'src/utils/bytes';
+import { FilterUtil } from 'src/utils/filter.util';
 
 @Injectable()
 export class TimelineService extends BaseService {
   async getTimeBuckets(auth: AuthDto, dto: TimeBucketDto): Promise<TimeBucketsResponseDto[]> {
     await this.timeBucketChecks(auth, dto);
+
+    // Check if this is a dynamic album
+    if (dto.albumId) {
+      const album = await this.albumRepository.getById(dto.albumId, { withAssets: false });
+      if (album?.dynamic && album.filters) {
+        // For dynamic albums, get assets via search and then create buckets manually
+        return this.getTimeBucketsForDynamicAlbum(auth, dto, album.filters);
+      }
+    }
+
     const timeBucketOptions = await this.buildTimeBucketOptions(auth, dto);
     return await this.assetRepository.getTimeBuckets(timeBucketOptions);
   }
@@ -18,6 +30,16 @@ export class TimelineService extends BaseService {
   // pre-jsonified response
   async getTimeBucket(auth: AuthDto, dto: TimeBucketAssetDto): Promise<string> {
     await this.timeBucketChecks(auth, dto);
+
+    // Check if this is a dynamic album
+    if (dto.albumId) {
+      const album = await this.albumRepository.getById(dto.albumId, { withAssets: false });
+      if (album?.dynamic && album.filters) {
+        // For dynamic albums, get assets via search and then filter by time bucket
+        return this.getTimeBucketForDynamicAlbum(auth, dto, album.filters);
+      }
+    }
+
     const timeBucketOptions = await this.buildTimeBucketOptions(auth, { ...dto });
 
     // TODO: use id cursor for pagination
@@ -25,6 +47,115 @@ export class TimelineService extends BaseService {
     return bucket.assets;
   }
 
+  private async getTimeBucketsForDynamicAlbum(
+    auth: AuthDto,
+    dto: TimeBucketDto,
+    filters: any,
+  ): Promise<TimeBucketsResponseDto[]> {
+    // Convert album filters to search options
+    const searchOptions = FilterUtil.convertFiltersToSearchOptions(filters, auth.user.id);
+
+    // Get all matching assets
+    const searchResult = await this.searchRepository.searchMetadata(
+      { page: 1, size: 50000 }, // Large page size to get all matching assets
+      { ...searchOptions, orderDirection: dto.order === 'asc' ? 'asc' : 'desc' },
+    );
+
+    // Group assets by time bucket
+    const buckets = new Map<string, number>();
+
+    for (const asset of searchResult.items) {
+      const assetDate = new Date(asset.fileCreatedAt || asset.localDateTime);
+      // Create time bucket in YYYY-MM format
+      const timeBucket = `${assetDate.getFullYear()}-${String(assetDate.getMonth() + 1).padStart(2, '0')}-01`;
+      buckets.set(timeBucket, (buckets.get(timeBucket) || 0) + 1);
+    }
+
+    // Convert to response format and sort
+    return Array.from(buckets.entries())
+      .map(([timeBucket, count]) => ({ timeBucket, count }))
+      .sort((a, b) => b.timeBucket.localeCompare(a.timeBucket)); // Newest first
+  }
+
+  private async getTimeBucketForDynamicAlbum(auth: AuthDto, dto: TimeBucketAssetDto, filters: any): Promise<string> {
+    // Convert album filters to search options
+    const searchOptions = FilterUtil.convertFiltersToSearchOptions(filters, auth.user.id);
+
+    // Get all matching assets
+    const searchResult = await this.searchRepository.searchMetadata(
+      { page: 1, size: 50000 }, // Large page size to get all matching assets
+      { ...searchOptions, orderDirection: dto.order === 'asc' ? 'asc' : 'desc' },
+    );
+
+    // Filter assets by the specific time bucket
+    const [year, month] = dto.timeBucket.split('-').map(Number);
+    const startDate = new Date(year, month - 1, 1);
+    const endDate = new Date(year, month, 0, 23, 59, 59, 999);
+
+    const bucketAssets = searchResult.items.filter((asset: any) => {
+      const assetDate = new Date(asset.fileCreatedAt || asset.localDateTime);
+      return assetDate >= startDate && assetDate <= endDate;
+    });
+
+    // Format the response to match AssetRepository.getTimeBucket structure
+    // This needs to be in the same aggregated array format
+    const aggregatedResponse = {
+      id: bucketAssets.map((asset: any) => asset.id),
+      ownerId: bucketAssets.map((asset: any) => asset.ownerId),
+      visibility: bucketAssets.map((asset: any) => asset.visibility || 'TIMELINE'),
+      isFavorite: bucketAssets.map((asset: any) => asset.isFavorite || false),
+      isImage: bucketAssets.map((asset: any) => asset.type === 'IMAGE'),
+      isTrashed: bucketAssets.map(() => false), // Dynamic album assets are never trashed
+      thumbhash: bucketAssets.map((asset: any) => (asset.thumbhash ? hexOrBufferToBase64(asset.thumbhash) : null)),
+      fileCreatedAt: bucketAssets.map((asset: any) => asset.fileCreatedAt || asset.localDateTime),
+      localOffsetHours: bucketAssets.map((asset: any) => {
+        // Calculate offset hours from fileCreatedAt and localDateTime if available
+        if (asset.fileCreatedAt && asset.localDateTime) {
+          const fileDate = new Date(asset.fileCreatedAt);
+          const localDate = new Date(asset.localDateTime);
+          return (localDate.getTime() - fileDate.getTime()) / (1000 * 60 * 60);
+        }
+        return 0; // Default offset
+      }),
+      duration: bucketAssets.map((asset: any) => asset.duration || null),
+      city: bucketAssets.map((asset: any) => asset.exifInfo?.city || null),
+      country: bucketAssets.map((asset: any) => asset.exifInfo?.country || null),
+      projectionType: bucketAssets.map((asset: any) => asset.exifInfo?.projectionType || null),
+      livePhotoVideoId: bucketAssets.map((asset: any) => asset.livePhotoVideoId || null),
+      ratio: bucketAssets.map((asset: any) => {
+        // Calculate aspect ratio from exif info if available
+        if (asset.exifInfo?.exifImageWidth && asset.exifInfo?.exifImageHeight) {
+          // Check for orientation that would swap dimensions
+          const orientation = asset.exifInfo.orientation;
+          const isRotated = ['5', '6', '7', '8', '-90', '90'].includes(String(orientation));
+
+          const width = asset.exifInfo.exifImageWidth;
+          const height = asset.exifInfo.exifImageHeight;
+
+          if (width === 0 || height === 0) return 1;
+
+          if (isRotated) {
+            return Math.round((height / width) * 1000) / 1000;
+          } else {
+            return Math.round((width / height) * 1000) / 1000;
+          }
+        }
+        return 1; // Default ratio
+      }),
+      status: bucketAssets.map((asset: any) => asset.status || 'AVAILABLE'),
+      ...(dto.withStacked && {
+        stack: bucketAssets.map((asset: any) => {
+          if (asset.stackId && asset.stackCount) {
+            return [asset.stackId, String(asset.stackCount)];
+          }
+          return null;
+        }),
+      }),
+    };
+
+    return JSON.stringify(aggregatedResponse);
+  }
+
   private async buildTimeBucketOptions(auth: AuthDto, dto: TimeBucketDto): Promise<TimeBucketOptions> {
     const { userId, ...options } = dto;
     let userIds: string[] | undefined = undefined;
diff --git a/server/src/utils/access.ts b/server/src/utils/access.ts
index b639643b6..6dfd574ca 100644
--- a/server/src/utils/access.ts
+++ b/server/src/utils/access.ts
@@ -96,6 +96,10 @@ const checkSharedLinkAccess = async (
       return sharedLink.allowUpload ? await access.album.checkSharedLinkAccess(sharedLinkId, ids) : new Set();
     }
 
+    case Permission.TIMELINE_READ: {
+      return await access.asset.checkSharedLinkAccess(sharedLinkId, ids);
+    }
+
     default: {
       return new Set<string>();
     }
diff --git a/server/src/utils/database.ts b/server/src/utils/database.ts
index 191e02eb6..232a02533 100644
--- a/server/src/utils/database.ts
+++ b/server/src/utils/database.ts
@@ -241,19 +241,33 @@ export function inAlbums<O>(qb: SelectQueryBuilder<DB, 'assets', O>, albumIds: s
   );
 }
 
-export function hasTags<O>(qb: SelectQueryBuilder<DB, 'assets', O>, tagIds: string[]) {
-  return qb.innerJoin(
-    (eb) =>
-      eb
-        .selectFrom('tag_asset')
-        .select('assetsId')
-        .innerJoin('tags_closure', 'tag_asset.tagsId', 'tags_closure.id_descendant')
-        .where('tags_closure.id_ancestor', '=', anyUuid(tagIds))
-        .groupBy('assetsId')
-        .having((eb) => eb.fn.count('tags_closure.id_ancestor').distinct(), '>=', tagIds.length)
-        .as('has_tags'),
-    (join) => join.onRef('has_tags.assetsId', '=', 'assets.id'),
-  );
+export function hasTags<O>(qb: SelectQueryBuilder<DB, 'assets', O>, tagIds: string[], operator: 'and' | 'or' = 'and') {
+  if (operator === 'and') {
+    // All tags must be present (existing logic)
+    return qb.innerJoin(
+      (eb) =>
+        eb
+          .selectFrom('tag_asset')
+          .select('assetsId')
+          .innerJoin('tags_closure', 'tag_asset.tagsId', 'tags_closure.id_descendant')
+          .where('tags_closure.id_ancestor', '=', anyUuid(tagIds))
+          .groupBy('assetsId')
+          .having((eb) => eb.fn.count('tags_closure.id_ancestor').distinct(), '>=', tagIds.length)
+          .as('has_tags'),
+      (join) => join.onRef('has_tags.assetsId', '=', 'assets.id'),
+    );
+  } else {
+    // Any tag can be present (OR logic)
+    return qb.where((eb) =>
+      eb.exists(
+        eb
+          .selectFrom('tag_asset')
+          .innerJoin('tags_closure', 'tag_asset.tagsId', 'tags_closure.id_descendant')
+          .whereRef('tag_asset.assetsId', '=', 'assets.id')
+          .where('tags_closure.id_ancestor', 'in', tagIds),
+      ),
+    );
+  }
 }
 
 export function withOwner(eb: ExpressionBuilder<DB, 'assets'>) {
@@ -306,7 +320,9 @@ export function searchAssetBuilder(kysely: Kysely<DB>, options: AssetSearchBuild
     .selectFrom('assets')
     .where('assets.visibility', '=', visibility)
     .$if(!!options.albumIds && options.albumIds.length > 0, (qb) => inAlbums(qb, options.albumIds!))
-    .$if(!!options.tagIds && options.tagIds.length > 0, (qb) => hasTags(qb, options.tagIds!))
+    .$if(!!options.tagIds && options.tagIds.length > 0, (qb) =>
+      hasTags(qb, options.tagIds!, options.tagOperator || 'and'),
+    )
     .$if(!!options.personIds && options.personIds.length > 0, (qb) => hasPeople(qb, options.personIds!))
     .$if(!!options.createdBefore, (qb) => qb.where('assets.createdAt', '<=', options.createdBefore!))
     .$if(!!options.createdAfter, (qb) => qb.where('assets.createdAt', '>=', options.createdAfter!))
diff --git a/server/src/utils/filter.util.ts b/server/src/utils/filter.util.ts
new file mode 100644
index 000000000..343927dc9
--- /dev/null
+++ b/server/src/utils/filter.util.ts
@@ -0,0 +1,254 @@
+import { AlbumFilterType } from 'src/enum';
+
+/**
+ * Album filter structure for type safety
+ */
+export interface AlbumFilter {
+  type: AlbumFilterType;
+  value: any;
+}
+
+/**
+ * Utility functions for processing album filters
+ */
+export class FilterUtil {
+  /**
+   * Filter assets by time bucket (year-month)
+   * @param assets Array of assets to filter
+   * @param timeBucket Time bucket in format YYYY-MM-DD
+   * @returns Filtered assets that fall within the time bucket
+   */
+  static filterAssetsByTimeBucket<T extends { fileCreatedAt?: Date | string }>(assets: T[], timeBucket: string): T[] {
+    // Parse the time bucket (format: YYYY-MM-DD)
+    const [year, month] = timeBucket.split('-').map(Number);
+    const startDate = new Date(year, month - 1, 1); // First day of the month
+    const endDate = new Date(year, month, 0); // Last day of the month
+
+    // Filter assets by the time bucket
+    return assets.filter((asset) => {
+      if (!asset.fileCreatedAt) return false;
+      const assetDate = new Date(asset.fileCreatedAt);
+      return assetDate >= startDate && assetDate <= endDate;
+    });
+  }
+
+  /**
+   * Validate album filters
+   * @param filters Array of album filters to validate
+   * @returns Array of validation errors (empty if valid)
+   */
+  static validateFilters(filters: AlbumFilter[]): string[] {
+    const errors: string[] = [];
+
+    if (!filters || filters.length === 0) {
+      return errors;
+    }
+
+    for (const filter of filters) {
+      if (!filter.type) {
+        errors.push('Filter type is required');
+        continue;
+      }
+
+      if (!filter.value) {
+        errors.push(`Filter value is required for type: ${filter.type}`);
+        continue;
+      }
+
+      // Validate specific filter types
+      switch (filter.type) {
+        case AlbumFilterType.TAG:
+          if (typeof filter.value !== 'string' && !Array.isArray(filter.value)) {
+            errors.push('Tag filter value must be a string or array of strings');
+          }
+          break;
+        case AlbumFilterType.PERSON:
+          if (typeof filter.value !== 'string' && !Array.isArray(filter.value)) {
+            errors.push('Person filter value must be a string or array of strings');
+          }
+          break;
+        case AlbumFilterType.LOCATION:
+          if (typeof filter.value !== 'string') {
+            errors.push('Location filter value must be a string');
+          }
+          break;
+        case AlbumFilterType.DATE_RANGE:
+          if (typeof filter.value !== 'object' || !filter.value.start || !filter.value.end) {
+            errors.push('Date range filter value must be an object with start and end dates');
+          }
+          break;
+        case AlbumFilterType.ASSET_TYPE:
+          if (!['IMAGE', 'VIDEO'].includes(filter.value as string)) {
+            errors.push('Asset type filter value must be either IMAGE or VIDEO');
+          }
+          break;
+        case AlbumFilterType.METADATA:
+          if (typeof filter.value !== 'object') {
+            errors.push('Metadata filter value must be an object');
+          }
+          break;
+        default:
+          errors.push(`Unknown filter type: ${filter.type}`);
+      }
+    }
+
+    return errors;
+  }
+
+  /**
+   * Normalize filter values for consistent processing
+   * @param filters Array of album filters to normalize
+   * @returns Array of normalized filters
+   */
+  static normalizeFilters(filters: AlbumFilter[]): AlbumFilter[] {
+    if (!filters || filters.length === 0) {
+      return [];
+    }
+
+    return filters.map((filter) => {
+      const normalized = { ...filter };
+
+      // Normalize string arrays to ensure consistent format
+      if (filter.type === AlbumFilterType.TAG || filter.type === AlbumFilterType.PERSON) {
+        if (typeof filter.value === 'string') {
+          normalized.value = [filter.value];
+        } else if (Array.isArray(filter.value)) {
+          normalized.value = filter.value.filter((v: any) => v && typeof v === 'string');
+        }
+      }
+
+      // Normalize location values
+      if (filter.type === AlbumFilterType.LOCATION) {
+        if (typeof filter.value === 'string') {
+          normalized.value = filter.value.trim();
+        }
+      }
+
+      // Normalize date ranges
+      if (filter.type === AlbumFilterType.DATE_RANGE && typeof filter.value === 'object') {
+        const dateRange = filter.value as { start?: string; end?: string };
+        if (dateRange.start && dateRange.end) {
+          normalized.value = {
+            start: new Date(dateRange.start).toISOString(),
+            end: new Date(dateRange.end).toISOString(),
+          };
+        }
+      }
+
+      return normalized;
+    });
+  }
+
+  /**
+   * Convert legacy dynamic album filters to new album filter format
+   * @param legacyFilters Array of legacy filters with filterType and filterValue
+   * @returns Array of new album filters
+   */
+  static convertLegacyFilters(legacyFilters: Array<{ filterType: string; filterValue: any }>): AlbumFilter[] {
+    if (!legacyFilters || legacyFilters.length === 0) {
+      return [];
+    }
+
+    return legacyFilters.map((filter) => ({
+      type: filter.filterType as any,
+      value: filter.filterValue,
+    }));
+  }
+
+  /**
+   * Check if filters are equivalent (for deduplication)
+   * @param filter1 First filter
+   * @param filter2 Second filter
+   * @returns True if filters are equivalent
+   */
+  static areFiltersEquivalent(filter1: AlbumFilter, filter2: AlbumFilter): boolean {
+    if (filter1.type !== filter2.type) {
+      return false;
+    }
+
+    // Deep comparison for complex values
+    return JSON.stringify(filter1.value) === JSON.stringify(filter2.value);
+  }
+
+  /**
+   * Remove duplicate filters from an array
+   * @param filters Array of filters to deduplicate
+   * @returns Array of unique filters
+   */
+  static deduplicateFilters(filters: AlbumFilter[]): AlbumFilter[] {
+    if (!filters || filters.length === 0) {
+      return [];
+    }
+
+    const unique: AlbumFilter[] = [];
+
+    for (const filter of filters) {
+      if (!unique.some((existing) => FilterUtil.areFiltersEquivalent(existing, filter))) {
+        unique.push(filter);
+      }
+    }
+
+    return unique;
+  }
+
+  /**
+   * Convert dynamic album filters to search options for SearchRepository
+   * This centralizes the logic that was duplicated across multiple services
+   */
+  static convertFiltersToSearchOptions(filters: any, userId: string): any {
+    const searchOptions: any = {
+      userIds: [userId],
+      withDeleted: false,
+    };
+
+    // Handle the actual filter structure: {tags: [...], operator: "and", ...}
+    if (filters.tags && Array.isArray(filters.tags)) {
+      searchOptions.tagIds = filters.tags;
+      // Include the operator for tag filtering
+      if (filters.operator) {
+        searchOptions.tagOperator = filters.operator;
+      }
+    }
+
+    if (filters.people && Array.isArray(filters.people)) {
+      searchOptions.personIds = filters.people;
+    }
+
+    if (filters.location) {
+      if (typeof filters.location === 'string') {
+        searchOptions.city = filters.location;
+      } else if (typeof filters.location === 'object') {
+        if (filters.location.city) searchOptions.city = filters.location.city;
+        if (filters.location.state) searchOptions.state = filters.location.state;
+        if (filters.location.country) searchOptions.country = filters.location.country;
+      }
+    }
+
+    if (filters.dateRange && typeof filters.dateRange === 'object') {
+      if (filters.dateRange.start) {
+        searchOptions.takenAfter = new Date(filters.dateRange.start);
+      }
+      if (filters.dateRange.end) {
+        searchOptions.takenBefore = new Date(filters.dateRange.end);
+      }
+    }
+
+    if (filters.assetType) {
+      if (filters.assetType === 'IMAGE' || filters.assetType === 'VIDEO') {
+        searchOptions.type = filters.assetType;
+      }
+    }
+
+    if (filters.metadata && typeof filters.metadata === 'object') {
+      if (filters.metadata.isFavorite !== undefined) {
+        searchOptions.isFavorite = filters.metadata.isFavorite;
+      }
+      if (filters.metadata.make) searchOptions.make = filters.metadata.make;
+      if (filters.metadata.model) searchOptions.model = filters.metadata.model;
+      if (filters.metadata.lensModel) searchOptions.lensModel = filters.metadata.lensModel;
+      if (filters.metadata.rating !== undefined) searchOptions.rating = filters.metadata.rating;
+    }
+
+    return searchOptions;
+  }
+}
diff --git a/server/test/fixtures/album.stub.ts b/server/test/fixtures/album.stub.ts
index fd6a8678a..6e95005f2 100644
--- a/server/test/fixtures/album.stub.ts
+++ b/server/test/fixtures/album.stub.ts
@@ -21,6 +21,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   sharedWithUser: Object.freeze({
     id: 'album-2',
@@ -44,6 +46,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   sharedWithMultiple: Object.freeze({
     id: 'album-3',
@@ -71,6 +75,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   sharedWithAdmin: Object.freeze({
     id: 'album-3',
@@ -94,6 +100,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   oneAsset: Object.freeze({
     id: 'album-4',
@@ -112,6 +120,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   twoAssets: Object.freeze({
     id: 'album-4a',
@@ -130,6 +140,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   emptyWithValidThumbnail: Object.freeze({
     id: 'album-5',
@@ -148,5 +160,7 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
 };
diff --git a/server/test/fixtures/shared-link.stub.ts b/server/test/fixtures/shared-link.stub.ts
index f3096280d..a309f0288 100644
--- a/server/test/fixtures/shared-link.stub.ts
+++ b/server/test/fixtures/shared-link.stub.ts
@@ -100,6 +100,8 @@ const albumResponse: AlbumResponseDto = {
   assetCount: 1,
   isActivityEnabled: true,
   order: AssetOrder.DESC,
+  dynamic: false,
+  filters: null,
 };
 
 export const sharedLinkStub = {
@@ -183,6 +185,8 @@ export const sharedLinkStub = {
       sharedLinks: [],
       isActivityEnabled: true,
       order: AssetOrder.DESC,
+      dynamic: false,
+      filters: null,
       assets: [
         {
           id: 'id_1',
diff --git a/web/src/lib/components/album-page/album-card.svelte b/web/src/lib/components/album-page/album-card.svelte
index b6b44cadf..567aaee99 100644
--- a/web/src/lib/components/album-page/album-card.svelte
+++ b/web/src/lib/components/album-page/album-card.svelte
@@ -5,7 +5,7 @@
   import { getShortDateRange } from '$lib/utils/date-time';
   import type { AlbumResponseDto } from '@immich/sdk';
   import { IconButton } from '@immich/ui';
-  import { mdiDotsVertical } from '@mdi/js';
+  import { mdiDotsVertical, mdiFilterOutline } from '@mdi/js';
   import { t } from 'svelte-i18n';
 
   interface Props {
@@ -31,11 +31,38 @@
     e.preventDefault();
     onShowContextMenu?.(getContextMenuPositionFromEvent(e));
   };
+
+  // Computed properties for dynamic albums
+  let isDynamic = $derived(album?.dynamic === true);
+
+  // Count actual filter types, excluding the 'operator' property which is just metadata
+  let getFilterCount = $derived(() => {
+    if (!isDynamic || !album?.filters || typeof album.filters !== 'object') {
+      return 0;
+    }
+
+    const filters = album.filters as any;
+    let count = 0;
+
+    // Count each filter type that has content
+    if (filters.tags && Array.isArray(filters.tags) && filters.tags.length > 0) count++;
+    if (filters.people && Array.isArray(filters.people) && filters.people.length > 0) count++;
+    if (filters.location && Object.keys(filters.location || {}).length > 0) count++;
+    if (filters.dateRange && Object.keys(filters.dateRange || {}).length > 0) count++;
+    if (filters.assetType) count++;
+    if (filters.metadata && Object.keys(filters.metadata || {}).length > 0) count++;
+
+    return count;
+  });
+
+  let hasFilters = $derived(getFilterCount() > 0);
+  let filterCount = $derived(getFilterCount());
 </script>
 
 <div
   class="group relative rounded-2xl border border-transparent p-5 hover:bg-gray-100 hover:border-gray-200 dark:hover:border-gray-800 dark:hover:bg-gray-900"
   data-testid="album-card"
+  class:dynamic-album={isDynamic}
 >
   {#if onShowContextMenu}
     <div
@@ -56,6 +83,20 @@
     </div>
   {/if}
 
+  <!-- Dynamic album indicator -->
+  {#if isDynamic}
+    <div class="absolute start-3 top-3 z-10" data-testid="dynamic-indicator">
+      <div
+        class="flex items-center gap-1 rounded-full bg-immich-primary/90 px-2 py-1 text-xs text-white backdrop-blur-sm"
+      >
+        <svg class="h-3 w-3" viewBox="0 0 24 24" fill="currentColor">
+          <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
+        </svg>
+        <span>{$t('dynamic')}</span>
+      </div>
+    </div>
+  {/if}
+
   <AlbumCover {album} {preload} class="transition-all duration-300 hover:shadow-lg" />
 
   <div class="mt-4">
@@ -96,5 +137,51 @@
         <p>{$t('shared')}</p>
       {/if}
     </span>
+
+    <!-- Description for dynamic albums -->
+    {#if isDynamic && album.description}
+      <p class="line-clamp-2 text-xs text-gray-500 dark:text-gray-400 mt-1">
+        {album.description}
+      </p>
+    {/if}
+
+    <!-- Filter indicators for dynamic albums -->
+    {#if hasFilters}
+      <div class="flex items-center gap-1 mt-2 text-xs text-gray-500 dark:text-gray-400" data-testid="filter-indicator">
+        <IconButton
+          icon={mdiFilterOutline}
+          size="small"
+          color="secondary"
+          variant="ghost"
+          class="!p-0 !w-4 !h-4"
+          aria-label={$t('filters')}
+        />
+        <span>{$t('filters_count', { values: { count: filterCount } })}</span>
+      </div>
+    {/if}
   </div>
 </div>
+
+<style>
+  .dynamic-album {
+    position: relative;
+  }
+
+  .dynamic-album::before {
+    content: '';
+    position: absolute;
+    top: 0;
+    left: 0;
+    right: 0;
+    bottom: 0;
+    border-radius: 1rem;
+    background: linear-gradient(45deg, transparent, rgba(99, 102, 241, 0.1), transparent);
+    pointer-events: none;
+    opacity: 0;
+    transition: opacity 0.3s ease;
+  }
+
+  .dynamic-album:hover::before {
+    opacity: 1;
+  }
+</style>
diff --git a/web/src/lib/components/album-page/album-viewer.svelte b/web/src/lib/components/album-page/album-viewer.svelte
index 0866d3855..275e9c0f2 100644
--- a/web/src/lib/components/album-page/album-viewer.svelte
+++ b/web/src/lib/components/album-page/album-viewer.svelte
@@ -107,7 +107,7 @@
       {#snippet trailing()}
         <CastButton />
 
-        {#if sharedLink.allowUpload}
+        {#if sharedLink.allowUpload && !album.dynamic}
           <IconButton
             shape="round"
             color="secondary"
diff --git a/web/src/lib/components/album-page/albums-controls.svelte b/web/src/lib/components/album-page/albums-controls.svelte
index 1fff0c29a..8395c9e9d 100644
--- a/web/src/lib/components/album-page/albums-controls.svelte
+++ b/web/src/lib/components/album-page/albums-controls.svelte
@@ -14,13 +14,13 @@
     type AlbumGroupOptionMetadata,
     type AlbumSortOptionMetadata,
     collapseAllAlbumGroups,
-    createAlbumAndRedirect,
     expandAllAlbumGroups,
     findFilterOption,
     findGroupOptionMetadata,
     findSortOptionMetadata,
     getSelectedAlbumGroupOption,
     groupOptionsMetadata,
+    showCreateAlbumModal,
     sortOptionsMetadata,
   } from '$lib/utils/album-utils';
   import { Button, IconButton, Text } from '@immich/ui';
@@ -130,7 +130,7 @@
 <!-- Create Album -->
 <Button
   leadingIcon={mdiPlusBoxOutline}
-  onclick={() => createAlbumAndRedirect()}
+  onclick={() => showCreateAlbumModal()}
   size="small"
   variant="ghost"
   color="secondary"
diff --git a/web/src/lib/components/asset-viewer/actions/set-album-cover-action.svelte b/web/src/lib/components/asset-viewer/actions/set-album-cover-action.svelte
index c015c224f..9ba872ac9 100644
--- a/web/src/lib/components/asset-viewer/actions/set-album-cover-action.svelte
+++ b/web/src/lib/components/asset-viewer/actions/set-album-cover-action.svelte
@@ -24,6 +24,7 @@
           albumThumbnailAssetId: asset.id,
         },
       });
+
       notificationController.show({
         type: NotificationType.Info,
         message: $t('album_cover_updated'),
diff --git a/web/src/lib/components/asset-viewer/asset-viewer.svelte b/web/src/lib/components/asset-viewer/asset-viewer.svelte
index 2685818ba..3913da86b 100644
--- a/web/src/lib/components/asset-viewer/asset-viewer.svelte
+++ b/web/src/lib/components/asset-viewer/asset-viewer.svelte
@@ -11,6 +11,7 @@
   import type { TimelineAsset } from '$lib/managers/timeline-manager/types';
   import { closeEditorCofirm } from '$lib/stores/asset-editor.store';
   import { assetViewingStore } from '$lib/stores/asset-viewing.store';
+  import { isFaceEditMode } from '$lib/stores/face-edit.svelte';
   import { isShowDetail } from '$lib/stores/preferences.store';
   import { SlideshowNavigation, SlideshowState, slideshowStore } from '$lib/stores/slideshow.store';
   import { user } from '$lib/stores/user.store';
@@ -44,7 +45,6 @@
   import PhotoViewer from './photo-viewer.svelte';
   import SlideshowBar from './slideshow-bar.svelte';
   import VideoViewer from './video-wrapper-viewer.svelte';
-  import { isFaceEditMode } from '$lib/stores/face-edit.svelte';
 
   type HasAsset = boolean;
 
diff --git a/web/src/lib/components/shared-components/filter-display.svelte b/web/src/lib/components/shared-components/filter-display.svelte
new file mode 100644
index 000000000..c8b368ba7
--- /dev/null
+++ b/web/src/lib/components/shared-components/filter-display.svelte
@@ -0,0 +1,237 @@
+<script lang="ts">
+  import { getAllTags, type TagResponseDto } from '@immich/sdk';
+  import { onMount } from 'svelte';
+  import { t } from 'svelte-i18n';
+
+  interface Props {
+    filters: any;
+  }
+
+  let { filters }: Props = $props();
+
+  let allTags: TagResponseDto[] = $state([]);
+  let tagMap = $derived(Object.fromEntries(allTags.map((tag) => [tag.id, tag])));
+
+  onMount(async () => {
+    allTags = await getAllTags();
+  });
+</script>
+
+{#if filters && typeof filters === 'object'}
+  <div class="space-y-2">
+    <!-- Tag Filter -->
+    {#if filters.tags && Array.isArray(filters.tags) && filters.tags.length > 0}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-400 text-xs font-medium"
+        >
+          1
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_tag')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="flex items-center gap-2">
+              <span class="font-medium">{$t(filters.operator === 'and' ? 'operator_and' : 'operator_or')}:</span>
+              <span>{filters.tags.length} {$t('tags')}</span>
+            </div>
+            {#if filters.tags.length > 0}
+              <div class="text-xs text-gray-400 dark:text-gray-500">
+                {filters.tags
+                  .slice(0, 3)
+                  .map((tagId: string) => tagMap[tagId]?.value || tagId)
+                  .join(', ')}{filters.tags.length > 3 ? '...' : ''}
+              </div>
+            {/if}
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Person Filter -->
+    {#if filters.people && Array.isArray(filters.people) && filters.people.length > 0}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-400 text-xs font-medium"
+        >
+          2
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_person')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="flex items-center gap-2">
+              <span class="font-medium">{$t(filters.operator === 'and' ? 'operator_and' : 'operator_or')}:</span>
+              <span>{filters.people.length} {$t('people')}</span>
+            </div>
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Location Filter -->
+    {#if filters.location}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-purple-100 text-purple-600 dark:bg-purple-900 dark:text-purple-400 text-xs font-medium"
+        >
+          3
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_location')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            {#if typeof filters.location === 'string'}
+              <div class="flex items-center gap-2">
+                <span class="font-medium">{$t('location')}:</span>
+                <span>{filters.location}</span>
+              </div>
+            {:else if typeof filters.location === 'object'}
+              <div class="space-y-1">
+                {#if filters.location.city}
+                  <div class="flex items-center gap-2">
+                    <span class="font-medium">{$t('city')}:</span>
+                    <span>{filters.location.city}</span>
+                  </div>
+                {/if}
+                {#if filters.location.state}
+                  <div class="flex items-center gap-2">
+                    <span class="font-medium">{$t('state')}:</span>
+                    <span>{filters.location.state}</span>
+                  </div>
+                {/if}
+                {#if filters.location.country}
+                  <div class="flex items-center gap-2">
+                    <span class="font-medium">{$t('country')}:</span>
+                    <span>{filters.location.country}</span>
+                  </div>
+                {/if}
+              </div>
+            {/if}
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Date Range Filter -->
+    {#if filters.dateRange}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-orange-100 text-orange-600 dark:bg-orange-900 dark:text-orange-400 text-xs font-medium"
+        >
+          4
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_date_range')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="space-y-1">
+              {#if filters.dateRange.start && filters.dateRange.end}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">{$t('date_range')}:</span>
+                  <span
+                    >{new Date(filters.dateRange.start).toLocaleDateString()} - {new Date(
+                      filters.dateRange.end,
+                    ).toLocaleDateString()}</span
+                  >
+                </div>
+              {:else if filters.dateRange.start}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">From:</span>
+                  <span>{new Date(filters.dateRange.start).toLocaleDateString()}</span>
+                </div>
+              {:else if filters.dateRange.end}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">Until:</span>
+                  <span>{new Date(filters.dateRange.end).toLocaleDateString()}</span>
+                </div>
+              {/if}
+            </div>
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Asset Type Filter -->
+    {#if filters.assetType}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-red-100 text-red-600 dark:bg-red-900 dark:text-red-400 text-xs font-medium"
+        >
+          5
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_asset_type')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="space-y-1">
+              <div class="flex items-center gap-2">
+                <span class="font-medium">{$t('asset_type')}:</span>
+                <span>{$t(filters.assetType === 'IMAGE' ? 'images' : 'videos')}</span>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Metadata Filter -->
+    {#if filters.metadata}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-indigo-100 text-indigo-600 dark:bg-indigo-900 dark:text-indigo-400 text-xs font-medium"
+        >
+          6
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_metadata')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="space-y-1">
+              {#if filters.metadata.isFavorite !== undefined}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">{$t('favorites')}:</span>
+                  <span>{filters.metadata.isFavorite ? $t('yes') : $t('no')}</span>
+                </div>
+              {/if}
+              {#if filters.metadata.make}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">{$t('make')}:</span>
+                  <span>{filters.metadata.make}</span>
+                </div>
+              {/if}
+              {#if filters.metadata.model}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">{$t('model')}:</span>
+                  <span>{filters.metadata.model}</span>
+                </div>
+              {/if}
+            </div>
+          </div>
+        </div>
+      </div>
+    {/if}
+  </div>
+{:else}
+  <p class="text-sm text-gray-500 dark:text-gray-400">
+    {$t('no_filters_configured')}
+  </p>
+{/if}
diff --git a/web/src/lib/components/shared-components/filter-operator-selector.svelte b/web/src/lib/components/shared-components/filter-operator-selector.svelte
new file mode 100644
index 000000000..f808fd248
--- /dev/null
+++ b/web/src/lib/components/shared-components/filter-operator-selector.svelte
@@ -0,0 +1,34 @@
+<script lang="ts">
+  import SettingDropdown from '$lib/components/shared-components/settings/setting-dropdown.svelte';
+  import { mdiArrowUpThin, mdiArrowDownThin } from '@mdi/js';
+  import { t } from 'svelte-i18n';
+  import type { RenderedOption } from '../elements/dropdown.svelte';
+
+  interface Props {
+    selectedOperator: 'and' | 'or';
+    onOperatorChange: (operator: 'and' | 'or') => void;
+  }
+
+  let { selectedOperator = $bindable(), onOperatorChange }: Props = $props();
+
+  // Operator options for the dropdown
+  const operatorOptions: Record<'and' | 'or', RenderedOption> = {
+    and: { icon: mdiArrowUpThin, title: $t('operator_and') },
+    or: { icon: mdiArrowDownThin, title: $t('operator_or') },
+  };
+</script>
+
+<div class="flex flex-col gap-2">
+  <SettingDropdown
+    title={$t('filter_operator')}
+    subtitle={$t('filter_operator_description')}
+    options={Object.values(operatorOptions)}
+    selectedOption={operatorOptions[selectedOperator]}
+    onToggle={(option) => {
+      const newOperator = Object.keys(operatorOptions).find(key => operatorOptions[key as 'and' | 'or'] === option) as 'and' | 'or';
+      if (newOperator) {
+        onOperatorChange(newOperator);
+      }
+    }}
+  />
+</div> 
\ No newline at end of file
diff --git a/web/src/lib/components/shared-components/tag-selector.svelte b/web/src/lib/components/shared-components/tag-selector.svelte
new file mode 100644
index 000000000..43a07dc14
--- /dev/null
+++ b/web/src/lib/components/shared-components/tag-selector.svelte
@@ -0,0 +1,91 @@
+<script lang="ts">
+  import Icon from '$lib/components/elements/icon.svelte';
+  import Combobox, { type ComboBoxOption } from '$lib/components/shared-components/combobox.svelte';
+  import { getAllTags, type TagResponseDto } from '@immich/sdk';
+  import { mdiClose } from '@mdi/js';
+  import { onMount } from 'svelte';
+  import { t } from 'svelte-i18n';
+  import { SvelteSet } from 'svelte/reactivity';
+
+  interface Props {
+    selectedTagIds: SvelteSet<string>;
+    label?: string;
+    placeholder?: string;
+    showLabel?: boolean;
+    forceFocus?: boolean;
+  }
+
+  let { 
+    selectedTagIds = $bindable(), 
+    label = $t('tags'),
+    placeholder = $t('search_tags'),
+    showLabel = true,
+    forceFocus = false
+  }: Props = $props();
+
+  let allTags: TagResponseDto[] = $state([]);
+  let tagMap = $derived(Object.fromEntries(allTags.map((tag) => [tag.id, tag])));
+
+  onMount(async () => {
+    allTags = await getAllTags();
+  });
+
+  const handleSelect = (option?: ComboBoxOption) => {
+    if (!option || !option.id) {
+      return;
+    }
+
+    selectedTagIds.add(option.value);
+  };
+
+  const handleRemove = (tagId: string) => {
+    selectedTagIds.delete(tagId);
+  };
+</script>
+
+<div class="my-4 flex flex-col gap-2">
+  <Combobox
+    onSelect={handleSelect}
+    label={showLabel ? label : ''}
+    hideLabel={!showLabel}
+    defaultFirstOption
+    {forceFocus}
+    options={allTags.map((tag) => ({ id: tag.id, label: tag.value, value: tag.id }))}
+    {placeholder}
+  />
+</div>
+
+<!-- Selected Tags Display -->
+{#if selectedTagIds.size > 0}
+  <section class="flex flex-wrap pt-2 gap-1">
+    {#each selectedTagIds as tagId (tagId)}
+      {@const tag = tagMap[tagId]}
+      {#if tag}
+        <div class="flex group transition-all">
+          <span
+            class="inline-block h-min whitespace-nowrap ps-3 pe-1 group-hover:ps-3 py-1 text-center align-baseline leading-none text-gray-100 dark:text-immich-dark-gray bg-primary rounded-s-full hover:bg-immich-primary/80 dark:hover:bg-immich-dark-primary/80 transition-all"
+          >
+            <p class="text-sm">
+              {tag.value}
+            </p>
+          </span>
+
+          <button
+            type="button"
+            class="text-gray-100 dark:text-immich-dark-gray bg-immich-primary/95 dark:bg-immich-dark-primary/95 rounded-e-full place-items-center place-content-center pe-2 ps-1 py-1 hover:bg-immich-primary/80 dark:hover:bg-immich-dark-primary/80 transition-all"
+            title={$t('remove_tag')}
+            onclick={() => handleRemove(tagId)}
+          >
+            <Icon path={mdiClose} />
+          </button>
+        </div>
+      {/if}
+    {/each}
+  </section>
+{/if}
+
+{#if selectedTagIds.size === 0}
+  <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
+    {$t('select_tags_for_dynamic_album')}
+  </p>
+{/if} 
\ No newline at end of file
diff --git a/web/src/lib/managers/timeline-manager/internal/load-support.svelte.ts b/web/src/lib/managers/timeline-manager/internal/load-support.svelte.ts
index ebe8acbec..3546f01ad 100644
--- a/web/src/lib/managers/timeline-manager/internal/load-support.svelte.ts
+++ b/web/src/lib/managers/timeline-manager/internal/load-support.svelte.ts
@@ -19,6 +19,9 @@ export async function loadFromTimeBuckets(
 
   const timeBucket = toISOYearMonthUTC(monthGroup.yearMonth);
   const key = authManager.key;
+
+  // Unified timeline fetch for both regular and dynamic albums
+  // The enhanced backend now handles dynamic filtering automatically
   const bucketResponse = await getTimeBucket(
     {
       ...options,
diff --git a/web/src/lib/managers/timeline-manager/types.ts b/web/src/lib/managers/timeline-manager/types.ts
index 8e5523758..3de57705d 100644
--- a/web/src/lib/managers/timeline-manager/types.ts
+++ b/web/src/lib/managers/timeline-manager/types.ts
@@ -6,6 +6,7 @@ export type AssetApiGetTimeBucketsRequest = Parameters<typeof import('@immich/sd
 export type TimelineManagerOptions = Omit<AssetApiGetTimeBucketsRequest, 'size'> & {
   timelineAlbumId?: string;
   deferInit?: boolean;
+  _forceReload?: number;
 };
 
 export type AssetDescriptor = { id: string };
diff --git a/web/src/lib/modals/CreateAlbumModal.svelte b/web/src/lib/modals/CreateAlbumModal.svelte
new file mode 100644
index 000000000..27362df19
--- /dev/null
+++ b/web/src/lib/modals/CreateAlbumModal.svelte
@@ -0,0 +1,211 @@
+<script lang="ts">
+  import type { RenderedOption } from '$lib/components/elements/dropdown.svelte';
+  import {
+    notificationController,
+    NotificationType,
+  } from '$lib/components/shared-components/notification/notification';
+  import SettingDropdown from '$lib/components/shared-components/settings/setting-dropdown.svelte';
+  import TagSelector from '$lib/components/shared-components/tag-selector.svelte';
+  import { handleError } from '$lib/utils/handle-error';
+  import { createAlbum, type AlbumResponseDto } from '@immich/sdk';
+  import { Button, HStack, Modal, ModalBody, ModalFooter } from '@immich/ui';
+  import { mdiFilter, mdiFolderOutline, mdiMultiplication, mdiPlus } from '@mdi/js';
+  import { t } from 'svelte-i18n';
+  import { SvelteSet } from 'svelte/reactivity';
+
+  interface Props {
+    onClose: (album?: AlbumResponseDto) => void;
+    shared?: boolean;
+    assetIds?: string[];
+  }
+
+  let { onClose, shared = false, assetIds = [] }: Props = $props();
+
+  let albumName = $state('');
+  let albumDescription = $state('');
+  let isDynamic = $state(false);
+  let selectedTagIds = new SvelteSet<string>();
+  let selectedOperator: 'and' | 'or' = $state('or');
+  let isSubmitting = $state(false);
+
+  // Operator options for the dropdown
+  const operatorOptions: Record<'and' | 'or', RenderedOption> = {
+    or: { icon: mdiPlus, title: $t('operator_or') },
+    and: { icon: mdiMultiplication, title: $t('operator_and') },
+  };
+
+  // Form validation
+  let isValidRegularAlbum = $derived(!isSubmitting && albumName.trim().length > 0);
+  let isValidDynamicAlbum = $derived(!isSubmitting && albumName.trim().length > 0 && selectedTagIds.size > 0);
+  let disabled = $derived(isDynamic ? !isValidDynamicAlbum : !isValidRegularAlbum);
+
+  const handleSubmit = async () => {
+    if (!albumName.trim()) {
+      return;
+    }
+
+    if (isDynamic && selectedTagIds.size === 0) {
+      return;
+    }
+
+    isSubmitting = true;
+    try {
+      let createAlbumDto: any = {
+        albumName: albumName.trim(),
+        description: albumDescription.trim() || undefined,
+        dynamic: isDynamic,
+      };
+
+      // Add asset IDs for regular albums
+      if (!isDynamic && assetIds.length > 0) {
+        createAlbumDto.assetIds = assetIds;
+      }
+
+      // Add filters for dynamic albums
+      if (isDynamic) {
+        createAlbumDto.filters = {
+          tags: [...selectedTagIds],
+          operator: selectedOperator,
+        };
+      }
+
+      const album = await createAlbum({ createAlbumDto });
+
+      notificationController.show({
+        message: isDynamic
+          ? $t('dynamic_album_created', { values: { album: album.albumName } })
+          : $t('album_created_success', { values: { album: album.albumName } }),
+        type: NotificationType.Info,
+      });
+
+      onClose(album);
+    } catch (error) {
+      handleError(error, isDynamic ? $t('errors.failed_to_create_dynamic_album') : $t('errors.failed_to_create_album'));
+    } finally {
+      isSubmitting = false;
+    }
+  };
+
+  const onsubmit = async (event: Event) => {
+    event.preventDefault();
+    await handleSubmit();
+  };
+</script>
+
+<Modal
+  size="medium"
+  title={isDynamic ? $t('create_dynamic_album') : $t('create_album')}
+  icon={mdiFolderOutline}
+  {onClose}
+>
+  <ModalBody>
+    <div class="text-immich-primary dark:text-immich-dark-primary">
+      <p class="text-sm dark:text-immich-dark-fg mb-4">
+        {isDynamic ? $t('create_dynamic_album_description') : $t('create_album_description')}
+      </p>
+    </div>
+
+    <form {onsubmit} autocomplete="off" id="create-album-form">
+      <!-- Album Type Toggle -->
+      <div class="my-4 flex flex-col gap-2">
+        <label class="immich-form-label">{$t('album_type')}</label>
+        <div class="flex gap-2">
+          <Button
+            size="small"
+            variant={!isDynamic ? 'filled' : 'ghost'}
+            color={!isDynamic ? 'primary' : 'secondary'}
+            leadingIcon={mdiFolderOutline}
+            onclick={() => (isDynamic = false)}
+          >
+            {$t('regular_album')}
+          </Button>
+          <Button
+            size="small"
+            variant={isDynamic ? 'filled' : 'ghost'}
+            color={isDynamic ? 'primary' : 'secondary'}
+            leadingIcon={mdiFilter}
+            onclick={() => (isDynamic = true)}
+          >
+            {$t('dynamic_album')}
+          </Button>
+        </div>
+        <p class="text-xs text-gray-500 dark:text-gray-400">
+          {isDynamic ? $t('dynamic_album_type_description') : $t('regular_album_type_description')}
+        </p>
+      </div>
+
+      <!-- Album Name -->
+      <div class="my-4 flex flex-col gap-2">
+        <label class="immich-form-label" for="album-name">{$t('name')}</label>
+        <input
+          class="immich-form-input"
+          id="album-name"
+          type="text"
+          bind:value={albumName}
+          placeholder={$t('enter_album_name')}
+          required
+          autofocus
+        />
+      </div>
+
+      <!-- Album Description -->
+      <div class="my-4 flex flex-col gap-2">
+        <label class="immich-form-label" for="album-description">{$t('description')}</label>
+        <textarea
+          class="immich-form-input"
+          id="album-description"
+          bind:value={albumDescription}
+          placeholder={$t('enter_album_description')}
+          rows="3"
+        />
+      </div>
+
+      <!-- Dynamic Album Filters -->
+      {#if isDynamic}
+        <div class="my-4 flex flex-col gap-2">
+          <TagSelector bind:selectedTagIds />
+        </div>
+
+        <!-- Operator Selection -->
+        {#if selectedTagIds.size > 1}
+          <div class="my-4 flex flex-col gap-2">
+            <SettingDropdown
+              title={$t('filter_operator')}
+              subtitle={$t('filter_operator_description')}
+              options={Object.values(operatorOptions)}
+              selectedOption={operatorOptions[selectedOperator]}
+              onToggle={(option) => {
+                const newOperator = Object.keys(operatorOptions).find(
+                  (key) => operatorOptions[key as 'and' | 'or'] === option,
+                ) as 'and' | 'or';
+                if (newOperator) {
+                  selectedOperator = newOperator;
+                }
+              }}
+            />
+          </div>
+        {/if}
+      {/if}
+
+      <!-- Asset Count Info for Regular Albums -->
+      {#if !isDynamic && assetIds.length > 0}
+        <div class="my-4 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
+          <p class="text-sm text-gray-600 dark:text-gray-400">
+            {$t('assets_will_be_added', { values: { count: assetIds.length } })}
+          </p>
+        </div>
+      {/if}
+    </form>
+  </ModalBody>
+
+  <ModalFooter>
+    <HStack fullWidth>
+      <Button shape="round" color="secondary" fullWidth onclick={() => onClose()}>
+        {$t('cancel')}
+      </Button>
+      <Button type="submit" shape="round" fullWidth form="create-album-form" {disabled}>
+        {$t('create')}
+      </Button>
+    </HStack>
+  </ModalFooter>
+</Modal>
diff --git a/web/src/lib/modals/DynamicAlbumFiltersModal.svelte b/web/src/lib/modals/DynamicAlbumFiltersModal.svelte
new file mode 100644
index 000000000..07de46e73
--- /dev/null
+++ b/web/src/lib/modals/DynamicAlbumFiltersModal.svelte
@@ -0,0 +1,128 @@
+<script lang="ts">
+  import SettingDropdown from '$lib/components/shared-components/settings/setting-dropdown.svelte';
+  import TagSelector from '$lib/components/shared-components/tag-selector.svelte';
+  import { handleError } from '$lib/utils/handle-error';
+  import { updateAlbumInfo, type AlbumResponseDto } from '@immich/sdk';
+  import { Button, HStack, Modal, ModalBody, ModalFooter } from '@immich/ui';
+  import { mdiArrowDownThin, mdiArrowUpThin } from '@mdi/js';
+  import { t } from 'svelte-i18n';
+  import { SvelteSet } from 'svelte/reactivity';
+  import type { RenderedOption } from '../components/elements/dropdown.svelte';
+  import { notificationController, NotificationType } from '../components/shared-components/notification/notification';
+
+  interface Props {
+    album: AlbumResponseDto;
+    onClose: (result?: { action: 'updated'; album: AlbumResponseDto }) => void;
+  }
+
+  let { album, onClose }: Props = $props();
+
+  let selectedTagIds = $state(new SvelteSet<string>());
+  let selectedOperator: 'and' | 'or' = $state('and');
+  let isSubmitting = $state(false);
+
+  // Operator options for the dropdown
+  const operatorOptions: Record<'and' | 'or', RenderedOption> = {
+    and: { icon: mdiArrowUpThin, title: $t('operator_and') },
+    or: { icon: mdiArrowDownThin, title: $t('operator_or') },
+  };
+
+  // Pre-populate selected tags and operator from existing filters
+  $effect(() => {
+    if (album.filters && typeof album.filters === 'object') {
+      // Handle flat filter structure: {tags: [...], operator: "and", ...}
+      const filters = album.filters as any;
+      if (filters.tags && Array.isArray(filters.tags)) {
+        // Clear existing tags and add new ones
+        selectedTagIds.clear();
+        for (const tagId of filters.tags) {
+          selectedTagIds.add(tagId);
+        }
+      }
+      // Set the operator from existing filter
+      if (filters.operator) {
+        selectedOperator = filters.operator as 'and' | 'or';
+      }
+    }
+  });
+
+  const handleSubmit = async () => {
+    if (selectedTagIds.size === 0) {
+      return;
+    }
+
+    isSubmitting = true;
+    try {
+      const updatedAlbum = await updateAlbumInfo({
+        id: album.id,
+        updateAlbumDto: {
+          filters: {
+            tags: [...selectedTagIds],
+            operator: selectedOperator,
+          },
+        },
+      });
+
+      notificationController.show({
+        message: $t('album_updated', { values: { album: updatedAlbum.albumName } }),
+        type: NotificationType.Info,
+      });
+
+      onClose({ action: 'updated', album: updatedAlbum });
+    } catch (error) {
+      handleError(error, $t('errors.unable_to_save_album'));
+    } finally {
+      isSubmitting = false;
+    }
+  };
+
+  const onsubmit = async (event: Event) => {
+    event.preventDefault();
+    await handleSubmit();
+  };
+
+  let disabled = $derived(selectedTagIds.size === 0 || isSubmitting);
+</script>
+
+<Modal title={$t('filters')} onClose={() => onClose()} size="medium">
+  <form id="edit-dynamic-album-filters-form" {onsubmit}>
+    <ModalBody>
+      <!-- Dynamic Album Filters -->
+      <div class="my-4 flex flex-col gap-2">
+        <label class="immich-form-label" for="tag-selector">{$t('filters')}</label>
+        <TagSelector bind:selectedTagIds />
+      </div>
+
+      <!-- Operator Selection -->
+      {#if selectedTagIds.size > 1}
+        <div class="my-4 flex flex-col gap-2">
+          <SettingDropdown
+            title={$t('filter_operator')}
+            subtitle={$t('filter_operator_description')}
+            options={Object.values(operatorOptions)}
+            selectedOption={operatorOptions[selectedOperator]}
+            onToggle={(option) => {
+              const newOperator = Object.keys(operatorOptions).find(
+                (key) => operatorOptions[key as 'and' | 'or'] === option,
+              ) as 'and' | 'or';
+              if (newOperator) {
+                selectedOperator = newOperator;
+              }
+            }}
+          />
+        </div>
+      {/if}
+    </ModalBody>
+
+    <ModalFooter>
+      <HStack fullWidth>
+        <Button shape="round" color="secondary" fullWidth onclick={() => onClose()}>
+          {$t('cancel')}
+        </Button>
+        <Button type="submit" shape="round" fullWidth form="edit-dynamic-album-filters-form" {disabled}>
+          {$t('save')}
+        </Button>
+      </HStack>
+    </ModalFooter>
+  </form>
+</Modal>
diff --git a/web/src/lib/modals/SharedLinkCreateModal.svelte b/web/src/lib/modals/SharedLinkCreateModal.svelte
index b4b9eaf98..9ee4f714e 100644
--- a/web/src/lib/modals/SharedLinkCreateModal.svelte
+++ b/web/src/lib/modals/SharedLinkCreateModal.svelte
@@ -19,7 +19,12 @@
     editingLink?: SharedLinkResponseDto | undefined;
   }
 
-  let { onClose, albumId = $bindable(undefined), assetIds = $bindable([]), editingLink = undefined }: Props = $props();
+  let {
+    onClose,
+    albumId = $bindable(undefined),
+    assetIds = $bindable([]),
+    editingLink = undefined,
+  }: Props = $props();
 
   let sharedLink: string | null = $state(null);
   let description = $state('');
@@ -51,7 +56,9 @@
     })),
   ]);
 
-  let shareType = $derived(albumId ? SharedLinkType.Album : SharedLinkType.Individual);
+  let shareType = $derived(
+    albumId ? SharedLinkType.Album : SharedLinkType.Individual,
+  );
 
   $effect(() => {
     if (!showMetadata) {
@@ -154,6 +161,8 @@
       {/if}
     {/if}
 
+
+
     {#if shareType === SharedLinkType.Individual}
       {#if !editingLink}
         <div>{$t('create_link_to_share_description')}</div>
diff --git a/web/src/lib/utils/album-utils.ts b/web/src/lib/utils/album-utils.ts
index 1a4097b78..427b5d847 100644
--- a/web/src/lib/utils/album-utils.ts
+++ b/web/src/lib/utils/album-utils.ts
@@ -44,6 +44,16 @@ export const createAlbumAndRedirect = async (name?: string, assetIds?: string[])
   }
 };
 
+export const showCreateAlbumModal = async (assetIds?: string[]) => {
+  const { modalManager } = await import('$lib/managers/modal-manager.svelte');
+  const { default: CreateAlbumModal } = await import('$lib/modals/CreateAlbumModal.svelte');
+
+  const album = await modalManager.show(CreateAlbumModal, { assetIds });
+  if (album) {
+    await goto(`${AppRoute.ALBUMS}/${album.id}`);
+  }
+};
+
 /**
  * -------------
  * Album Sorting
diff --git a/web/src/routes/(user)/albums/+page.svelte b/web/src/routes/(user)/albums/+page.svelte
index 239c6cc38..8526f1572 100644
--- a/web/src/routes/(user)/albums/+page.svelte
+++ b/web/src/routes/(user)/albums/+page.svelte
@@ -1,16 +1,16 @@
 <script lang="ts">
-  import type { PageData } from './$types';
   import { scrollMemory } from '$lib/actions/scroll-memory';
-  import { AlbumFilter, albumViewSettings } from '$lib/stores/preferences.store';
-  import { createAlbumAndRedirect } from '$lib/utils/album-utils';
-  import UserPageLayout from '$lib/components/layouts/user-page-layout.svelte';
   import AlbumsControls from '$lib/components/album-page/albums-controls.svelte';
   import Albums from '$lib/components/album-page/albums-list.svelte';
-  import EmptyPlaceholder from '$lib/components/shared-components/empty-placeholder.svelte';
   import GroupTab from '$lib/components/elements/group-tab.svelte';
   import SearchBar from '$lib/components/elements/search-bar.svelte';
+  import UserPageLayout from '$lib/components/layouts/user-page-layout.svelte';
+  import EmptyPlaceholder from '$lib/components/shared-components/empty-placeholder.svelte';
   import { AppRoute } from '$lib/constants';
+  import { AlbumFilter, albumViewSettings } from '$lib/stores/preferences.store';
+  import { showCreateAlbumModal } from '$lib/utils/album-utils';
   import { t } from 'svelte-i18n';
+  import type { PageData } from './$types';
 
   interface Props {
     data: PageData;
@@ -52,7 +52,7 @@
     bind:albumGroupIds={albumGroups}
   >
     {#snippet empty()}
-      <EmptyPlaceholder text={$t('no_albums_message')} onClick={() => createAlbumAndRedirect()} />
+      <EmptyPlaceholder text={$t('no_albums_message')} onClick={() => showCreateAlbumModal()} />
     {/snippet}
   </Albums>
 </UserPageLayout>
diff --git a/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte b/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte
index aa535a30e..484771ef7 100644
--- a/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte
+++ b/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte
@@ -27,6 +27,7 @@
   import ButtonContextMenu from '$lib/components/shared-components/context-menu/button-context-menu.svelte';
   import MenuOption from '$lib/components/shared-components/context-menu/menu-option.svelte';
   import ControlAppBar from '$lib/components/shared-components/control-app-bar.svelte';
+  import FilterDisplay from '$lib/components/shared-components/filter-display.svelte';
   import {
     NotificationType,
     notificationController,
@@ -40,6 +41,7 @@
   import AlbumOptionsModal from '$lib/modals/AlbumOptionsModal.svelte';
   import AlbumShareModal from '$lib/modals/AlbumShareModal.svelte';
   import AlbumUsersModal from '$lib/modals/AlbumUsersModal.svelte';
+  import DynamicAlbumFiltersModal from '$lib/modals/DynamicAlbumFiltersModal.svelte';
   import QrCodeModal from '$lib/modals/QrCodeModal.svelte';
   import SharedLinkCreateModal from '$lib/modals/SharedLinkCreateModal.svelte';
   import { AssetInteraction } from '$lib/stores/asset-interaction.svelte';
@@ -68,6 +70,7 @@
     deleteAlbum,
     getAlbumInfo,
     updateAlbumInfo,
+    type AlbumResponseDto,
     type AlbumUserAddDto,
   } from '@immich/sdk';
   import { Button, IconButton } from '@immich/ui';
@@ -80,6 +83,7 @@
     mdiImageOutline,
     mdiImagePlusOutline,
     mdiLink,
+    mdiPencilOutline,
     mdiPlus,
     mdiPresentationPlay,
     mdiShareVariantOutline,
@@ -179,6 +183,18 @@
 
   const refreshAlbum = async () => {
     album = await getAlbumInfo({ id: album.id, withoutAssets: true });
+
+    // For dynamic albums, also refresh the timeline manager to get new filtered assets
+    if (album.dynamic && viewMode === AlbumPageViewMode.VIEW) {
+      // Clear the timeline manager's cache and force a complete reload
+      timelineManager.months = [];
+      await timelineManager.updateOptions({
+        albumId: album.id,
+        order: albumOrder,
+        // Add a unique timestamp to ensure options are always different
+        _forceReload: Date.now(),
+      });
+    }
   };
   const handleAddAssets = async () => {
     const assetIds = timelineInteraction.selectedAssets.map((asset) => asset.id);
@@ -305,6 +321,7 @@
           albumThumbnailAssetId: assetId,
         },
       });
+
       notificationController.show({
         type: NotificationType.Info,
         message: $t('album_cover_updated'),
@@ -320,7 +337,8 @@
     }
   });
 
-  let album = $derived(data.album);
+  let album = $state(data.album);
+
   let albumId = $derived(album.id);
 
   $effect(() => {
@@ -439,6 +457,26 @@
       }
     }
   };
+
+  const handleEditDynamicAlbumFilters = async () => {
+    const result = await modalManager.show(DynamicAlbumFiltersModal, { album });
+
+    if (
+      result &&
+      typeof result === 'object' &&
+      'action' in result &&
+      result.action === 'updated' &&
+      'album' in result
+    ) {
+      album = result.album as AlbumResponseDto;
+
+      // For dynamic albums, refresh the album data and timeline manager to get new filtered assets
+      if (album.dynamic && viewMode === AlbumPageViewMode.VIEW) {
+        // First refresh the album data to get updated assetCount
+        await refreshAlbum();
+      }
+    }
+  };
 </script>
 
 <div class="flex overflow-hidden" use:scrollMemoryClearer={{ routeStartsWith: AppRoute.ALBUMS }}>
@@ -472,20 +510,8 @@
               {/if}
 
               <!-- ALBUM SHARING -->
-              {#if album.albumUsers.length > 0 || (album.hasSharedLink && isOwned)}
+              {#if album.albumUsers.length > 0}
                 <div class="my-3 flex gap-x-1">
-                  <!-- link -->
-                  {#if album.hasSharedLink && isOwned}
-                    <IconButton
-                      aria-label={$t('create_link_to_share')}
-                      color="secondary"
-                      size="medium"
-                      shape="round"
-                      icon={mdiLink}
-                      onclick={handleShareLink}
-                    />
-                  {/if}
-
                   <!-- owner -->
                   <button type="button" onclick={handleEditUsers}>
                     <UserAvatar user={album.owner} size="md" />
@@ -524,23 +550,52 @@
               {/if}
               <!-- ALBUM DESCRIPTION -->
               <AlbumDescription id={album.id} bind:description={album.description} {isOwned} />
+
+              <!-- DYNAMIC ALBUM FILTERS -->
+              {#if album.dynamic && album.filters && typeof album.filters === 'object'}
+                {@const filters = album.filters as any}
+                {#if filters.tags || filters.people || filters.location || filters.dateRange || filters.assetType || filters.metadata}
+                  <div class="mt-6">
+                    <div class="mb-3 flex items-center justify-between">
+                      <h3 class="text-sm font-medium text-gray-900 dark:text-white">
+                        {$t('filters')}
+                      </h3>
+                      {#if isOwned}
+                        <IconButton
+                          aria-label={$t('edit')}
+                          color="secondary"
+                          size="small"
+                          shape="round"
+                          icon={mdiPencilOutline}
+                          onclick={handleEditDynamicAlbumFilters}
+                        />
+                      {/if}
+                    </div>
+                    <FilterDisplay filters={album.filters} />
+                  </div>
+                {/if}
+              {/if}
             </section>
           {/if}
 
           {#if album.assetCount === 0}
             <section id="empty-album" class=" mt-[200px] flex place-content-center place-items-center">
               <div class="w-[300px]">
-                <p class="text-xs dark:text-immich-dark-fg">{$t('add_photos').toUpperCase()}</p>
-                <button
-                  type="button"
-                  onclick={() => (viewMode = AlbumPageViewMode.SELECT_ASSETS)}
-                  class="mt-5 bg-subtle flex w-full place-items-center gap-6 rounded-2xl border px-8 py-8 text-immich-fg transition-all hover:bg-gray-100 dark:hover:bg-gray-500/20 hover:text-immich-primary dark:border-none dark:text-immich-dark-fg dark:hover:text-immich-dark-primary"
-                >
-                  <span class="text-text-immich-primary dark:text-immich-dark-primary"
-                    ><Icon path={mdiPlus} size="24" />
-                  </span>
-                  <span class="text-lg">{$t('select_photos')}</span>
-                </button>
+                {#if !album.dynamic}
+                  <p class="text-xs dark:text-immich-dark-fg">{$t('add_photos').toUpperCase()}</p>
+                  <button
+                    type="button"
+                    onclick={() => (viewMode = AlbumPageViewMode.SELECT_ASSETS)}
+                    class="mt-5 bg-subtle flex w-full place-items-center gap-6 rounded-2xl border px-8 py-8 text-immich-fg transition-all hover:bg-gray-100 dark:hover:bg-gray-500/20 hover:text-immich-primary dark:border-none dark:text-immich-dark-fg dark:hover:text-immich-dark-primary"
+                  >
+                    <span class="text-text-immich-primary dark:text-immich-dark-primary"
+                      ><Icon path={mdiPlus} size="24" />
+                    </span>
+                    <span class="text-lg">{$t('select_photos')}</span>
+                  </button>
+                {:else}
+                  <p class="text-center text-gray-500 dark:text-gray-400">{$t('no_assets_found_in_dynamic_album')}</p>
+                {/if}
               </div>
             </section>
           {/if}
@@ -617,7 +672,7 @@
           {#snippet trailing()}
             <CastButton />
 
-            {#if isEditor}
+            {#if isEditor && !album.dynamic}
               <IconButton
                 variant="ghost"
                 shape="round"
@@ -699,7 +754,7 @@
         </ControlAppBar>
       {/if}
 
-      {#if viewMode === AlbumPageViewMode.SELECT_ASSETS}
+      {#if viewMode === AlbumPageViewMode.SELECT_ASSETS && !album.dynamic}
         <ControlAppBar onClose={handleCloseSelectAssets}>
           {#snippet leading()}
             <p class="text-lg dark:text-immich-dark-fg">
@@ -712,16 +767,18 @@
           {/snippet}
 
           {#snippet trailing()}
-            <button
-              type="button"
-              onclick={handleSelectFromComputer}
-              class="rounded-lg px-6 py-2 text-sm font-medium text-immich-primary transition-all hover:bg-immich-primary/10 dark:text-immich-dark-primary dark:hover:bg-immich-dark-primary/25"
-            >
-              {$t('select_from_computer')}
-            </button>
-            <Button size="small" disabled={!timelineInteraction.selectionActive} onclick={handleAddAssets}
-              >{$t('done')}</Button
-            >
+            {#if !album.dynamic}
+              <button
+                type="button"
+                onclick={handleSelectFromComputer}
+                class="rounded-lg px-6 py-2 text-sm font-medium text-immich-primary transition-all hover:bg-immich-primary/10 dark:text-immich-dark-primary dark:hover:bg-immich-dark-primary/25"
+              >
+                {$t('select_from_computer')}
+              </button>
+              <Button size="small" disabled={!timelineInteraction.selectionActive} onclick={handleAddAssets}
+                >{$t('done')}</Button
+              >
+            {/if}
           {/snippet}
         </ControlAppBar>
       {/if}
diff --git a/web/src/routes/(user)/sharing/+page.svelte b/web/src/routes/(user)/sharing/+page.svelte
index a55452b5d..22c4bacab 100644
--- a/web/src/routes/(user)/sharing/+page.svelte
+++ b/web/src/routes/(user)/sharing/+page.svelte
@@ -13,7 +13,7 @@
     SortOrder,
     type AlbumViewSettings,
   } from '$lib/stores/preferences.store';
-  import { createAlbumAndRedirect } from '$lib/utils/album-utils';
+  import { showCreateAlbumModal } from '$lib/utils/album-utils';
   import { Button, HStack, Text } from '@immich/ui';
   import { mdiLink, mdiPlusBoxOutline } from '@mdi/js';
   import { t } from 'svelte-i18n';
@@ -41,7 +41,7 @@
     <HStack gap={0}>
       <Button
         leadingIcon={mdiPlusBoxOutline}
-        onclick={() => createAlbumAndRedirect()}
+        onclick={() => showCreateAlbumModal()}
         size="small"
         variant="ghost"
         color="secondary"
