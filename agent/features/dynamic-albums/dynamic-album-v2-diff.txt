diff --git a/server/src/dtos/album.dto.ts b/server/src/dtos/album.dto.ts
index 40e51ef72..79f6dac1d 100644
--- a/server/src/dtos/album.dto.ts
+++ b/server/src/dtos/album.dto.ts
@@ -46,6 +46,12 @@ export class CreateAlbumDto {
   @Optional()
   description?: string;
 
+  @ValidateBoolean({ optional: true })
+  dynamic?: boolean;
+
+  @Optional()
+  filters?: object | null;
+
   @Optional()
   @IsArray()
   @ValidateNested({ each: true })
@@ -65,6 +71,12 @@ export class UpdateAlbumDto {
   @IsString()
   description?: string;
 
+  @ValidateBoolean({ optional: true })
+  dynamic?: boolean;
+
+  @Optional()
+  filters?: object | null;
+
   @ValidateUUID({ optional: true })
   albumThumbnailAssetId?: string;
 
@@ -123,6 +135,8 @@ export class AlbumResponseDto {
   ownerId!: string;
   albumName!: string;
   description!: string;
+  dynamic!: boolean;
+  filters!: object | null;
   createdAt!: Date;
   updatedAt!: Date;
   albumThumbnailAssetId!: string | null;
@@ -148,6 +162,8 @@ export type MapAlbumDto = {
   sharedLinks?: AuthSharedLink[];
   albumName: string;
   description: string;
+  dynamic: boolean;
+  filters: object | null;
   albumThumbnailAssetId: string | null;
   createdAt: Date;
   updatedAt: Date;
@@ -188,6 +204,8 @@ export const mapAlbum = (entity: MapAlbumDto, withAssets: boolean, auth?: AuthDt
   return {
     albumName: entity.albumName,
     description: entity.description,
+    dynamic: entity.dynamic,
+    filters: entity.filters,
     albumThumbnailAssetId: entity.albumThumbnailAssetId,
     createdAt: entity.createdAt,
     updatedAt: entity.updatedAt,
diff --git a/server/src/enum.ts b/server/src/enum.ts
index d211420ab..80d420190 100644
--- a/server/src/enum.ts
+++ b/server/src/enum.ts
@@ -675,3 +675,17 @@ export enum AssetVisibility {
   HIDDEN = 'hidden',
   LOCKED = 'locked',
 }
+
+export enum AlbumFilterType {
+  TAG = 'tag',
+  PERSON = 'person',
+  LOCATION = 'location',
+  DATE_RANGE = 'date_range',
+  ASSET_TYPE = 'asset_type',
+  METADATA = 'metadata',
+}
+
+export enum AlbumFilterOperator {
+  AND = 'and',
+  OR = 'or',
+}
diff --git a/server/src/queries/access.repository.sql b/server/src/queries/access.repository.sql
index 402bbdcfa..c488b0ace 100644
--- a/server/src/queries/access.repository.sql
+++ b/server/src/queries/access.repository.sql
@@ -151,6 +151,39 @@ where
   "sessions"."userId" = $1
   and "sessions"."id" in ($2)
 
+-- AccessRepository.dynamicAlbum.checkOwnerAccess
+select
+  "dynamic_albums"."id"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" in ($1)
+  and "dynamic_albums"."ownerId" = $2
+  and "dynamic_albums"."deletedAt" is null
+
+-- AccessRepository.dynamicAlbum.checkSharedAlbumAccess
+select
+  "dynamic_albums"."id"
+from
+  "dynamic_albums"
+  left join "dynamic_album_shares" as "albumShares" on "albumShares"."dynamicAlbumId" = "dynamic_albums"."id"
+  left join "users" on "users"."id" = "albumShares"."userId"
+  and "users"."deletedAt" is null
+where
+  "dynamic_albums"."id" in ($1)
+  and "dynamic_albums"."deletedAt" is null
+  and "users"."id" = $2
+  and "albumShares"."role" in ($3, $4)
+
+-- AccessRepository.dynamicAlbum.checkSharedLinkAccess
+select
+  "shared_links"."dynamicAlbumId"
+from
+  "shared_links"
+where
+  "shared_links"."id" = $1
+  and "shared_links"."dynamicAlbumId" in ($2)
+
 -- AccessRepository.memory.checkOwnerAccess
 select
   "memories"."id"
diff --git a/server/src/queries/dynamic.album.repository.sql b/server/src/queries/dynamic.album.repository.sql
new file mode 100644
index 000000000..1167b9781
--- /dev/null
+++ b/server/src/queries/dynamic.album.repository.sql
@@ -0,0 +1,535 @@
+-- NOTE: This file is auto generated by ./sql-generator
+
+-- DynamicAlbumRepository.getById
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.getOwned
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."ownerId" = $1
+  and "dynamic_albums"."deletedAt" is null
+order by
+  "dynamic_albums"."createdAt" desc
+
+-- DynamicAlbumRepository.getShared
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  exists (
+    select
+    from
+      "dynamic_album_shares" as "shares"
+    where
+      "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      and "shares"."userId" = $1
+  )
+  and "dynamic_albums"."deletedAt" is null
+order by
+  "dynamic_albums"."createdAt" desc
+
+-- DynamicAlbumRepository.getMetadataForIds
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.getAssets
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.getAssetCount
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.getFirstAssetForThumbnail
+select
+  "dynamic_albums".*,
+  (
+    select
+      to_json(obj)
+    from
+      (
+        select
+          "id",
+          "name",
+          "email",
+          "avatarColor",
+          "profileImagePath",
+          "profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+      ) as obj
+  ) as "owner",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          "shares"."role",
+          "shares"."createdAt",
+          (
+            select
+              to_json(obj)
+            from
+              (
+                select
+                  "id",
+                  "name",
+                  "email",
+                  "avatarColor",
+                  "profileImagePath",
+                  "profileChangedAt"
+                from
+                  "users"
+                where
+                  "users"."id" = "shares"."userId"
+              ) as obj
+          ) as "user"
+        from
+          "dynamic_album_shares" as "shares"
+        where
+          "shares"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "sharedUsers",
+  (
+    select
+      coalesce(json_agg(agg), '[]')
+    from
+      (
+        select
+          *
+        from
+          "dynamic_album_filters"
+        where
+          "dynamic_album_filters"."dynamicAlbumId" = "dynamic_albums"."id"
+      ) as agg
+  ) as "filters"
+from
+  "dynamic_albums"
+where
+  "dynamic_albums"."id" = $1
+  and "dynamic_albums"."deletedAt" is null
+
+-- DynamicAlbumRepository.delete
+delete from "dynamic_albums"
+where
+  "id" = $1
+
+-- DynamicAlbumRepository.softDelete
+update "dynamic_albums"
+set
+  "deletedAt" = now()
+where
+  "id" = $1
+
+-- DynamicAlbumRepository.restore
+update "dynamic_albums"
+set
+  "deletedAt" = $1
+where
+  "id" = $2
diff --git a/server/src/queries/shared.link.repository.sql b/server/src/queries/shared.link.repository.sql
index 1044c1c88..ff71b1a80 100644
--- a/server/src/queries/shared.link.repository.sql
+++ b/server/src/queries/shared.link.repository.sql
@@ -101,7 +101,8 @@ order by
 select distinct
   on ("shared_links"."createdAt") "shared_links".*,
   "assets"."assets",
-  to_json("album") as "album"
+  to_json("album") as "album",
+  to_json("dynamicAlbum") as "dynamicAlbum"
 from
   "shared_links"
   left join "shared_link__asset" on "shared_link__asset"."sharedLinksId" = "shared_links"."id"
@@ -147,13 +148,48 @@ from
       "albums"."id" = "shared_links"."albumId"
       and "albums"."deletedAt" is null
   ) as "album" on true
+  left join lateral (
+    select
+      "dynamic_albums".*,
+      to_json("owner") as "owner"
+    from
+      "dynamic_albums"
+      inner join lateral (
+        select
+          "users"."id",
+          "users"."email",
+          "users"."createdAt",
+          "users"."profileImagePath",
+          "users"."isAdmin",
+          "users"."shouldChangePassword",
+          "users"."deletedAt",
+          "users"."oauthId",
+          "users"."updatedAt",
+          "users"."storageLabel",
+          "users"."name",
+          "users"."quotaSizeInBytes",
+          "users"."quotaUsageInBytes",
+          "users"."status",
+          "users"."profileChangedAt"
+        from
+          "users"
+        where
+          "users"."id" = "dynamic_albums"."ownerId"
+          and "users"."deletedAt" is null
+      ) as "owner" on true
+    where
+      "dynamic_albums"."id" = "shared_links"."dynamicAlbumId"
+      and "dynamic_albums"."deletedAt" is null
+  ) as "dynamicAlbum" on true
 where
   "shared_links"."userId" = $1
   and (
     "shared_links"."type" = $2
     or "album"."id" is not null
+    or "dynamicAlbum"."id" is not null
   )
   and "shared_links"."albumId" = $3
+  and "shared_links"."dynamicAlbumId" = $4
 order by
   "shared_links"."createdAt" desc
 
diff --git a/server/src/repositories/access.repository.ts b/server/src/repositories/access.repository.ts
index 8863d117b..0c8fd0e23 100644
--- a/server/src/repositories/access.repository.ts
+++ b/server/src/repositories/access.repository.ts
@@ -245,7 +245,7 @@ class AssetAccess {
         sql`array[${sql.join([...assetIds])}]::uuid[] `,
       )
       .execute()
-      .then((rows) => {
+      .then((rows: any[]) => {
         const allowedIds = new Set<string>();
         for (const row of rows) {
           if (row.assetId && assetIds.has(row.assetId)) {
diff --git a/server/src/repositories/album.repository.ts b/server/src/repositories/album.repository.ts
index a52fa9c99..57b4cc805 100644
--- a/server/src/repositories/album.repository.ts
+++ b/server/src/repositories/album.repository.ts
@@ -121,22 +121,21 @@ export class AlbumRepository {
       return [];
     }
 
-    return (
-      this.db
-        .selectFrom('assets')
-        .$call(withDefaultVisibility)
-        .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'assets.id')
-        .select('album_assets.albumsId as albumId')
-        .select((eb) => eb.fn.min(sql<Date>`("assets"."localDateTime" AT TIME ZONE 'UTC'::text)::date`).as('startDate'))
-        .select((eb) => eb.fn.max(sql<Date>`("assets"."localDateTime" AT TIME ZONE 'UTC'::text)::date`).as('endDate'))
-        // lastModifiedAssetTimestamp is only used in mobile app, please remove if not need
-        .select((eb) => eb.fn.max('assets.updatedAt').as('lastModifiedAssetTimestamp'))
-        .select((eb) => sql<number>`${eb.fn.count('assets.id')}::int`.as('assetCount'))
-        .where('album_assets.albumsId', 'in', ids)
-        .where('assets.deletedAt', 'is', null)
-        .groupBy('album_assets.albumsId')
-        .execute()
-    );
+    // This method only handles regular (non-dynamic) albums.
+    // Dynamic album metadata is calculated in the service layer using search functionality.
+    return this.db
+      .selectFrom('assets')
+      .$call(withDefaultVisibility)
+      .innerJoin('albums_assets_assets as album_assets', 'album_assets.assetsId', 'assets.id')
+      .select('album_assets.albumsId as albumId')
+      .select((eb) => eb.fn.min(sql<Date>`("assets"."localDateTime" AT TIME ZONE 'UTC'::text)::date`).as('startDate'))
+      .select((eb) => eb.fn.max(sql<Date>`("assets"."localDateTime" AT TIME ZONE 'UTC'::text)::date`).as('endDate'))
+      .select((eb) => eb.fn.max('assets.updatedAt').as('lastModifiedAssetTimestamp'))
+      .select((eb) => sql<number>`${eb.fn.count('assets.id')}::int`.as('assetCount'))
+      .where('album_assets.albumsId', 'in', ids)
+      .where('assets.deletedAt', 'is', null)
+      .groupBy('album_assets.albumsId')
+      .execute();
   }
 
   @GenerateSql({ params: [DummyValue.UUID] })
diff --git a/server/src/repositories/asset.repository.ts b/server/src/repositories/asset.repository.ts
index f3e798d2b..afc2a6b87 100644
--- a/server/src/repositories/asset.repository.ts
+++ b/server/src/repositories/asset.repository.ts
@@ -11,22 +11,22 @@ import { AssetJobStatusTable } from 'src/schema/tables/asset-job-status.table';
 import { AssetTable } from 'src/schema/tables/asset.table';
 import { ExifTable } from 'src/schema/tables/exif.table';
 import {
-  anyUuid,
-  asUuid,
-  hasPeople,
-  removeUndefinedKeys,
-  truncatedDate,
-  unnest,
-  withDefaultVisibility,
-  withExif,
-  withFaces,
-  withFacesAndPeople,
-  withFiles,
-  withLibrary,
-  withOwner,
-  withSmartSearch,
-  withTagId,
-  withTags,
+    anyUuid,
+    asUuid,
+    hasPeople,
+    removeUndefinedKeys,
+    truncatedDate,
+    unnest,
+    withDefaultVisibility,
+    withExif,
+    withFaces,
+    withFacesAndPeople,
+    withFiles,
+    withLibrary,
+    withOwner,
+    withSmartSearch,
+    withTagId,
+    withTags,
 } from 'src/utils/database';
 import { globToSqlPattern } from 'src/utils/misc';
 
@@ -51,6 +51,7 @@ interface AssetBuilderOptions {
   isTrashed?: boolean;
   isDuplicate?: boolean;
   albumId?: string;
+  dynamicAlbumId?: string;
   tagId?: string;
   personId?: string;
   userIds?: string[];
diff --git a/server/src/repositories/search.repository.ts b/server/src/repositories/search.repository.ts
index 9026b795c..0ae1c4b52 100644
--- a/server/src/repositories/search.repository.ts
+++ b/server/src/repositories/search.repository.ts
@@ -90,6 +90,7 @@ export interface SearchPeopleOptions {
 
 export interface SearchTagOptions {
   tagIds?: string[];
+  tagOperator?: 'and' | 'or';
 }
 
 export interface SearchAlbumOptions {
diff --git a/server/src/repositories/shared-link.repository.ts b/server/src/repositories/shared-link.repository.ts
index 0875b535e..dae30d972 100644
--- a/server/src/repositories/shared-link.repository.ts
+++ b/server/src/repositories/shared-link.repository.ts
@@ -173,7 +173,6 @@ export class SharedLinkRepository {
       .selectFrom('shared_links')
       .where('shared_links.key', '=', key)
       .leftJoin('albums', 'albums.id', 'shared_links.albumId')
-      .where('albums.deletedAt', 'is', null)
       .select((eb) => [
         ...columns.authSharedLink,
         jsonObjectFrom(
@@ -181,6 +180,7 @@ export class SharedLinkRepository {
         ).as('user'),
       ])
       .where((eb) => eb.or([eb('shared_links.type', '=', SharedLinkType.INDIVIDUAL), eb('albums.id', 'is not', null)]))
+      .where('albums.deletedAt', 'is', null)
       .executeTakeFirst();
   }
 
@@ -248,7 +248,45 @@ export class SharedLinkRepository {
           .$castTo<MapAsset[]>()
           .as('assets'),
       )
-      .groupBy('shared_links.id')
+      .leftJoinLateral(
+        (eb) =>
+          eb
+            .selectFrom('albums')
+            .selectAll('albums')
+            .whereRef('albums.id', '=', 'shared_links.albumId')
+            .innerJoinLateral(
+              (eb) =>
+                eb
+                  .selectFrom('users')
+                  .select([
+                    'users.id',
+                    'users.email',
+                    'users.createdAt',
+                    'users.profileImagePath',
+                    'users.isAdmin',
+                    'users.shouldChangePassword',
+                    'users.deletedAt',
+                    'users.oauthId',
+                    'users.updatedAt',
+                    'users.storageLabel',
+                    'users.name',
+                    'users.quotaSizeInBytes',
+                    'users.quotaUsageInBytes',
+                    'users.status',
+                    'users.profileChangedAt',
+                  ])
+                  .whereRef('users.id', '=', 'albums.ownerId')
+                  .where('users.deletedAt', 'is', null)
+                  .as('owner'),
+              (join) => join.onTrue(),
+            )
+            .select((eb) => eb.fn.toJson('owner').as('owner'))
+            .where('albums.deletedAt', 'is', null)
+            .as('album'),
+        (join) => join.onTrue(),
+      )
+      .select((eb) => eb.fn.toJson('album').$castTo<Album | null>().as('album'))
+      .groupBy(['shared_links.id', sql`"album".*`])
       .executeTakeFirstOrThrow();
   }
 }
diff --git a/server/src/schema/migrations/1752487436191-DynamicAlbums.ts b/server/src/schema/migrations/1752487436191-DynamicAlbums.ts
new file mode 100644
index 000000000..5d2931986
--- /dev/null
+++ b/server/src/schema/migrations/1752487436191-DynamicAlbums.ts
@@ -0,0 +1,34 @@
+import { Kysely, sql } from 'kysely';
+
+export async function up(db: Kysely<any>): Promise<void> {
+  // Add dynamic boolean field to albums table
+  await sql`
+    ALTER TABLE albums 
+    ADD COLUMN dynamic boolean DEFAULT false NOT NULL
+  `.execute(db);
+
+  // Add filters JSONB field to albums table
+  await sql`
+    ALTER TABLE albums 
+    ADD COLUMN filters jsonb DEFAULT null
+  `.execute(db);
+
+  // Create indexes for performance
+  await sql`
+    CREATE INDEX IDX_albums_dynamic ON albums(dynamic)
+  `.execute(db);
+
+  await sql`
+    CREATE INDEX IDX_albums_filters ON albums USING gin(filters)
+  `.execute(db);
+}
+
+export async function down(db: Kysely<any>): Promise<void> {
+  // Remove indexes
+  await sql`DROP INDEX IF EXISTS IDX_albums_dynamic`.execute(db);
+  await sql`DROP INDEX IF EXISTS IDX_albums_filters`.execute(db);
+
+  // Remove columns
+  await sql`ALTER TABLE albums DROP COLUMN IF EXISTS filters`.execute(db);
+  await sql`ALTER TABLE albums DROP COLUMN IF EXISTS dynamic`.execute(db);
+}
diff --git a/server/src/schema/tables/album.table.ts b/server/src/schema/tables/album.table.ts
index e4cad8f46..10954317d 100644
--- a/server/src/schema/tables/album.table.ts
+++ b/server/src/schema/tables/album.table.ts
@@ -60,6 +60,12 @@ export class AlbumTable {
   @Column({ default: AssetOrder.DESC })
   order!: Generated<AssetOrder>;
 
+  @Column({ type: 'boolean', default: false })
+  dynamic!: Generated<boolean>;
+
+  @Column({ type: 'jsonb', nullable: true })
+  filters!: object | null;
+
   @UpdateIdColumn({ indexName: 'IDX_albums_update_id' })
   updateId!: Generated<string>;
 }
diff --git a/server/src/services/album.service.ts b/server/src/services/album.service.ts
index e49d4bc5f..9bae83d28 100644
--- a/server/src/services/album.service.ts
+++ b/server/src/services/album.service.ts
@@ -51,14 +51,81 @@ export class AlbumService extends BaseService {
       albums = await this.albumRepository.getOwned(ownerId);
     }
 
-    // Get asset count for each album. Then map the result to an object:
-    // { [albumId]: assetCount }
-    const results = await this.albumRepository.getMetadataForIds(albums.map((album) => album.id));
+    // Separate regular and dynamic albums
+    const regularAlbums = albums.filter((album) => !album.dynamic);
+    const dynamicAlbums = albums.filter((album) => album.dynamic);
+
+    // Get asset count for regular albums using the repository
+    const regularAlbumIds = regularAlbums.map((album) => album.id);
+    const results = regularAlbumIds.length > 0 ? await this.albumRepository.getMetadataForIds(regularAlbumIds) : [];
     const albumMetadata: Record<string, AlbumAssetCount> = {};
     for (const metadata of results) {
       albumMetadata[metadata.albumId] = metadata;
     }
 
+    // Calculate metadata for dynamic albums using search
+    for (const dynamicAlbum of dynamicAlbums) {
+      if (dynamicAlbum.filters) {
+        try {
+          const searchOptions = this.convertFiltersToSearchOptions(dynamicAlbum.filters, ownerId);
+          const searchResult = await this.searchRepository.searchMetadata(
+            { page: 1, size: 50000 }, // Large page size to get all matching assets
+            { ...searchOptions, orderDirection: dynamicAlbum.order === 'asc' ? 'asc' : 'desc' },
+          );
+
+          const assets = searchResult.items;
+
+          if (assets.length > 0) {
+            const dates = assets
+              .map((asset: any) => asset.fileCreatedAt || asset.localDateTime)
+              .filter(Boolean)
+              .map((date: any) => new Date(date))
+              .sort((a: Date, b: Date) => a.getTime() - b.getTime());
+
+            const updatedDates = assets
+              .map((asset: any) => asset.updatedAt)
+              .filter(Boolean)
+              .map((date: any) => new Date(date))
+              .sort((a: Date, b: Date) => b.getTime() - a.getTime());
+
+            albumMetadata[dynamicAlbum.id] = {
+              albumId: dynamicAlbum.id,
+              assetCount: assets.length,
+              startDate: dates.length > 0 ? dates[0] : null,
+              endDate: dates.length > 0 ? dates[dates.length - 1] : null,
+              lastModifiedAssetTimestamp: updatedDates.length > 0 ? updatedDates[0] : null,
+            };
+          } else {
+            albumMetadata[dynamicAlbum.id] = {
+              albumId: dynamicAlbum.id,
+              assetCount: 0,
+              startDate: null,
+              endDate: null,
+              lastModifiedAssetTimestamp: null,
+            };
+          }
+        } catch (error) {
+          // If search fails, use empty metadata
+          albumMetadata[dynamicAlbum.id] = {
+            albumId: dynamicAlbum.id,
+            assetCount: 0,
+            startDate: null,
+            endDate: null,
+            lastModifiedAssetTimestamp: null,
+          };
+        }
+      } else {
+        // No filters, so no assets
+        albumMetadata[dynamicAlbum.id] = {
+          albumId: dynamicAlbum.id,
+          assetCount: 0,
+          startDate: null,
+          endDate: null,
+          lastModifiedAssetTimestamp: null,
+        };
+      }
+    }
+
     return albums.map((album) => ({
       ...mapAlbumWithoutAssets(album),
       sharedLinks: undefined,
@@ -71,14 +138,85 @@ export class AlbumService extends BaseService {
   }
 
   async get(auth: AuthDto, id: string, dto: AlbumInfoDto): Promise<AlbumResponseDto> {
+    // throw new Error('Not implemented');
+    this.logger.debug(`AlbumService.get called with id: ${id}, withoutAssets: ${dto.withoutAssets}`);
     await this.requireAccess({ auth, permission: Permission.ALBUM_READ, ids: [id] });
     await this.albumRepository.updateThumbnails();
     const withAssets = dto.withoutAssets === undefined ? true : !dto.withoutAssets;
-    const album = await this.findOrFail(id, { withAssets });
+    const album = await this.findOrFail(id, { withAssets: false }); // Always load without assets first
+
+    this.logger.debug(
+      `Album data loaded: ${JSON.stringify(
+        {
+          id: album.id,
+          dynamic: album.dynamic,
+          filters: album.filters,
+          albumName: album.albumName,
+        },
+        null,
+        2,
+      )}`,
+    );
+
+    // Check if this is a dynamic album
+    this.logger.debug(`Album check - dynamic: ${album.dynamic}, filters: ${!!album.filters}`);
+    if (album.dynamic && album.filters) {
+      this.logger.debug('Processing dynamic album - entering logic');
+      // Convert album filters to search options for SearchRepository
+      const dynamicSearchOptions = this.convertFiltersToSearchOptions(album.filters, auth.user.id);
+
+      // Always get the search result to calculate metadata, even if we don't need full assets
+      const searchResult = await this.searchRepository.searchMetadata(
+        { page: 1, size: 50000 }, // Large page size to get all matching assets
+        { ...dynamicSearchOptions, orderDirection: album.order === 'asc' ? 'asc' : 'desc' },
+      );
+
+      const foundAssets = searchResult.items;
+      this.logger.debug(`Found ${foundAssets.length} assets for dynamic album`);
+
+      // For dynamic albums, calculate metadata from the actual search results
+      let startDate: Date | undefined;
+      let endDate: Date | undefined;
+      let lastModifiedAssetTimestamp: Date | undefined;
+
+      if (foundAssets.length > 0) {
+        const dates = foundAssets
+          .map((asset: any) => asset.fileCreatedAt || asset.localDateTime)
+          .filter(Boolean)
+          .map((date: any) => new Date(date))
+          .sort((a: Date, b: Date) => a.getTime() - b.getTime());
+
+        if (dates.length > 0) {
+          startDate = dates[0];
+          endDate = dates[dates.length - 1];
+        }
+
+        const updatedDates = foundAssets
+          .map((asset: any) => asset.updatedAt)
+          .filter(Boolean)
+          .map((date: any) => new Date(date))
+          .sort((a: Date, b: Date) => b.getTime() - a.getTime());
+
+        if (updatedDates.length > 0) {
+          lastModifiedAssetTimestamp = updatedDates[0];
+        }
+      }
+
+      return {
+        ...mapAlbum({ ...album, assets: withAssets ? foundAssets : [] }, withAssets, auth),
+        startDate,
+        endDate,
+        assetCount: foundAssets.length,
+        lastModifiedAssetTimestamp,
+      };
+    }
+
+    // For regular albums, use the existing logic
+    const albumWithAssets = withAssets ? await this.findOrFail(id, { withAssets: true }) : album;
     const [albumMetadataForIds] = await this.albumRepository.getMetadataForIds([album.id]);
 
     return {
-      ...mapAlbum(album, withAssets, auth),
+      ...mapAlbum(albumWithAssets, withAssets, auth),
       startDate: albumMetadataForIds?.startDate ?? undefined,
       endDate: albumMetadataForIds?.endDate ?? undefined,
       assetCount: albumMetadataForIds?.assetCount ?? 0,
@@ -100,12 +238,16 @@ export class AlbumService extends BaseService {
       }
     }
 
-    const allowedAssetIdsSet = await this.checkAccess({
-      auth,
-      permission: Permission.ASSET_SHARE,
-      ids: dto.assetIds || [],
-    });
-    const assetIds = [...allowedAssetIdsSet].map((id) => id);
+    // For dynamic albums, we don't need to check asset access or add assets
+    let assetIds: string[] = [];
+    if (!dto.dynamic) {
+      const allowedAssetIdsSet = await this.checkAccess({
+        auth,
+        permission: Permission.ASSET_SHARE,
+        ids: dto.assetIds || [],
+      });
+      assetIds = [...allowedAssetIdsSet].map((id) => id);
+    }
 
     const userMetadata = await this.userRepository.getMetadata(auth.user.id);
 
@@ -114,10 +256,12 @@ export class AlbumService extends BaseService {
         ownerId: auth.user.id,
         albumName: dto.albumName,
         description: dto.description,
-        albumThumbnailAssetId: assetIds[0] || null,
+        albumThumbnailAssetId: dto.dynamic ? null : assetIds[0] || null,
         order: getPreferences(userMetadata).albums.defaultAssetOrder,
+        dynamic: dto.dynamic || false,
+        filters: dto.filters || null,
       },
-      assetIds,
+      dto.dynamic ? [] : assetIds, // Don't add assets for dynamic albums
       albumUsers,
     );
 
@@ -131,23 +275,36 @@ export class AlbumService extends BaseService {
   async update(auth: AuthDto, id: string, dto: UpdateAlbumDto): Promise<AlbumResponseDto> {
     await this.requireAccess({ auth, permission: Permission.ALBUM_UPDATE, ids: [id] });
 
-    const album = await this.findOrFail(id, { withAssets: true });
+    const album = await this.findOrFail(id, { withAssets: false });
 
-    if (dto.albumThumbnailAssetId) {
+    // For dynamic albums, don't allow setting thumbnail from assets
+    if (dto.albumThumbnailAssetId && !album.dynamic) {
       const results = await this.albumRepository.getAssetIds(id, [dto.albumThumbnailAssetId]);
       if (results.size === 0) {
         throw new BadRequestException('Invalid album thumbnail');
       }
     }
+
+    // For dynamic albums, clear thumbnail if trying to set one
+    const albumThumbnailAssetId = album.dynamic ? null : dto.albumThumbnailAssetId;
+
     const updatedAlbum = await this.albumRepository.update(album.id, {
       id: album.id,
       albumName: dto.albumName,
       description: dto.description,
-      albumThumbnailAssetId: dto.albumThumbnailAssetId,
+      albumThumbnailAssetId: albumThumbnailAssetId,
       isActivityEnabled: dto.isActivityEnabled,
       order: dto.order,
+      dynamic: dto.dynamic ?? album.dynamic,
+      filters: dto.filters ?? album.filters,
     });
 
+    // For dynamic albums, return empty assets for now
+    // TODO: Implement proper dynamic album asset retrieval
+    if (updatedAlbum.dynamic) {
+      return mapAlbumWithoutAssets({ ...updatedAlbum, assets: [] });
+    }
+
     return mapAlbumWithoutAssets({ ...updatedAlbum, assets: album.assets });
   }
 
@@ -158,6 +315,14 @@ export class AlbumService extends BaseService {
 
   async addAssets(auth: AuthDto, id: string, dto: BulkIdsDto): Promise<BulkIdResponseDto[]> {
     const album = await this.findOrFail(id, { withAssets: false });
+
+    // Prevent adding assets to dynamic albums
+    if (album.dynamic) {
+      throw new BadRequestException(
+        'Cannot add assets to dynamic albums. Assets are automatically populated based on filters.',
+      );
+    }
+
     await this.requireAccess({ auth, permission: Permission.ALBUM_ADD_ASSET, ids: [id] });
 
     const results = await addAssets(
@@ -187,9 +352,17 @@ export class AlbumService extends BaseService {
   }
 
   async removeAssets(auth: AuthDto, id: string, dto: BulkIdsDto): Promise<BulkIdResponseDto[]> {
+    const album = await this.findOrFail(id, { withAssets: false });
+
+    // Prevent removing assets from dynamic albums
+    if (album.dynamic) {
+      throw new BadRequestException(
+        'Cannot remove assets from dynamic albums. Assets are automatically populated based on filters.',
+      );
+    }
+
     await this.requireAccess({ auth, permission: Permission.ALBUM_REMOVE_ASSET, ids: [id] });
 
-    const album = await this.findOrFail(id, { withAssets: false });
     const results = await removeAssets(
       auth,
       { access: this.accessRepository, bulk: this.albumRepository },
@@ -260,6 +433,66 @@ export class AlbumService extends BaseService {
     await this.albumUserRepository.update({ albumsId: id, usersId: userId }, { role: dto.role });
   }
 
+  /**
+   * Convert dynamic album filters to search options for SearchRepository
+   */
+  private convertFiltersToSearchOptions(filters: any, userId: string): any {
+    const searchOptions: any = {
+      userIds: [userId],
+      withDeleted: false,
+    };
+
+    // Handle the actual filter structure: {tags: [...], operator: "and", ...}
+    if (filters.tags && Array.isArray(filters.tags)) {
+      searchOptions.tagIds = filters.tags;
+      // Include the operator for tag filtering
+      if (filters.operator) {
+        searchOptions.tagOperator = filters.operator;
+      }
+    }
+
+    if (filters.people && Array.isArray(filters.people)) {
+      searchOptions.personIds = filters.people;
+    }
+
+    if (filters.location) {
+      if (typeof filters.location === 'string') {
+        searchOptions.city = filters.location;
+      } else if (typeof filters.location === 'object') {
+        if (filters.location.city) searchOptions.city = filters.location.city;
+        if (filters.location.state) searchOptions.state = filters.location.state;
+        if (filters.location.country) searchOptions.country = filters.location.country;
+      }
+    }
+
+    if (filters.dateRange && typeof filters.dateRange === 'object') {
+      if (filters.dateRange.start) {
+        searchOptions.takenAfter = new Date(filters.dateRange.start);
+      }
+      if (filters.dateRange.end) {
+        searchOptions.takenBefore = new Date(filters.dateRange.end);
+      }
+    }
+
+    if (filters.assetType) {
+      if (filters.assetType === 'IMAGE' || filters.assetType === 'VIDEO') {
+        searchOptions.type = filters.assetType;
+      }
+    }
+
+    if (filters.metadata && typeof filters.metadata === 'object') {
+      if (filters.metadata.isFavorite !== undefined) {
+        searchOptions.isFavorite = filters.metadata.isFavorite;
+      }
+      if (filters.metadata.make) searchOptions.make = filters.metadata.make;
+      if (filters.metadata.model) searchOptions.model = filters.metadata.model;
+      if (filters.metadata.lensModel) searchOptions.lensModel = filters.metadata.lensModel;
+      if (filters.metadata.rating !== undefined) searchOptions.rating = filters.metadata.rating;
+    }
+
+    return searchOptions;
+  }
+
   private async findOrFail(id: string, options: AlbumInfoOptions) {
     const album = await this.albumRepository.getById(id, options);
     if (!album) {
diff --git a/server/src/services/shared-link.service.ts b/server/src/services/shared-link.service.ts
index c70b31a3a..8bb55c431 100644
--- a/server/src/services/shared-link.service.ts
+++ b/server/src/services/shared-link.service.ts
@@ -19,9 +19,8 @@ import { getExternalDomain, OpenGraphTags } from 'src/utils/misc';
 @Injectable()
 export class SharedLinkService extends BaseService {
   async getAll(auth: AuthDto, { albumId }: SharedLinkSearchDto): Promise<SharedLinkResponseDto[]> {
-    return this.sharedLinkRepository
-      .getAll({ userId: auth.user.id, albumId })
-      .then((links) => links.map((link) => mapSharedLink(link)));
+    const links = await this.sharedLinkRepository.getAll({ userId: auth.user.id, albumId });
+    return links.map((link) => mapSharedLink(link));
   }
 
   async getMine(auth: AuthDto, dto: SharedLinkPasswordDto): Promise<SharedLinkResponseDto> {
@@ -30,7 +29,7 @@ export class SharedLinkService extends BaseService {
     }
 
     const sharedLink = await this.findOrFail(auth.user.id, auth.sharedLink.id);
-    const response = this.mapToSharedLink(sharedLink, { withExif: sharedLink.showExif });
+    const response = await this.mapToSharedLink(sharedLink, { withExif: sharedLink.showExif });
     if (sharedLink.password) {
       response.token = this.validateAndRefreshToken(sharedLink, dto);
     }
@@ -40,7 +39,7 @@ export class SharedLinkService extends BaseService {
 
   async get(auth: AuthDto, id: string): Promise<SharedLinkResponseDto> {
     const sharedLink = await this.findOrFail(auth.user.id, id);
-    return this.mapToSharedLink(sharedLink, { withExif: true });
+    return await this.mapToSharedLink(sharedLink, { withExif: true });
   }
 
   async create(auth: AuthDto, dto: SharedLinkCreateDto): Promise<SharedLinkResponseDto> {
@@ -78,7 +77,7 @@ export class SharedLinkService extends BaseService {
       showExif: dto.showMetadata ?? true,
     });
 
-    return this.mapToSharedLink(sharedLink, { withExif: true });
+    return await this.mapToSharedLink(sharedLink, { withExif: true });
   }
 
   async update(auth: AuthDto, id: string, dto: SharedLinkEditDto) {
@@ -93,7 +92,7 @@ export class SharedLinkService extends BaseService {
       allowDownload: dto.allowDownload,
       showExif: dto.showMetadata,
     });
-    return this.mapToSharedLink(sharedLink, { withExif: true });
+    return await this.mapToSharedLink(sharedLink, { withExif: true });
   }
 
   async remove(auth: AuthDto, id: string): Promise<void> {
@@ -194,8 +193,13 @@ export class SharedLinkService extends BaseService {
     };
   }
 
-  private mapToSharedLink(sharedLink: SharedLink, { withExif }: { withExif: boolean }) {
-    return withExif ? mapSharedLink(sharedLink) : mapSharedLinkWithoutMetadata(sharedLink);
+  private async mapToSharedLink(sharedLink: SharedLink, { withExif }: { withExif: boolean }) {
+    const baseResponse = withExif ? mapSharedLink(sharedLink) : mapSharedLinkWithoutMetadata(sharedLink);
+
+    // The mapSharedLink function already handles dynamic albums correctly
+    // No additional processing needed here
+
+    return baseResponse;
   }
 
   private validateAndRefreshToken(sharedLink: SharedLink, dto: SharedLinkPasswordDto): string {
diff --git a/server/src/services/timeline.service.ts b/server/src/services/timeline.service.ts
index abd536a97..739f7c602 100644
--- a/server/src/services/timeline.service.ts
+++ b/server/src/services/timeline.service.ts
@@ -6,11 +6,22 @@ import { TimeBucketOptions } from 'src/repositories/asset.repository';
 import { BaseService } from 'src/services/base.service';
 import { requireElevatedPermission } from 'src/utils/access';
 import { getMyPartnerIds } from 'src/utils/asset.util';
+import { hexOrBufferToBase64 } from 'src/utils/bytes';
 
 @Injectable()
 export class TimelineService extends BaseService {
   async getTimeBuckets(auth: AuthDto, dto: TimeBucketDto): Promise<TimeBucketsResponseDto[]> {
     await this.timeBucketChecks(auth, dto);
+
+    // Check if this is a dynamic album
+    if (dto.albumId) {
+      const album = await this.albumRepository.getById(dto.albumId, { withAssets: false });
+      if (album?.dynamic && album.filters) {
+        // For dynamic albums, get assets via search and then create buckets manually
+        return this.getTimeBucketsForDynamicAlbum(auth, dto, album.filters);
+      }
+    }
+
     const timeBucketOptions = await this.buildTimeBucketOptions(auth, dto);
     return await this.assetRepository.getTimeBuckets(timeBucketOptions);
   }
@@ -18,6 +29,16 @@ export class TimelineService extends BaseService {
   // pre-jsonified response
   async getTimeBucket(auth: AuthDto, dto: TimeBucketAssetDto): Promise<string> {
     await this.timeBucketChecks(auth, dto);
+
+    // Check if this is a dynamic album
+    if (dto.albumId) {
+      const album = await this.albumRepository.getById(dto.albumId, { withAssets: false });
+      if (album?.dynamic && album.filters) {
+        // For dynamic albums, get assets via search and then filter by time bucket
+        return this.getTimeBucketForDynamicAlbum(auth, dto, album.filters);
+      }
+    }
+
     const timeBucketOptions = await this.buildTimeBucketOptions(auth, { ...dto });
 
     // TODO: use id cursor for pagination
@@ -25,6 +46,175 @@ export class TimelineService extends BaseService {
     return bucket.assets;
   }
 
+  private async getTimeBucketsForDynamicAlbum(
+    auth: AuthDto,
+    dto: TimeBucketDto,
+    filters: any,
+  ): Promise<TimeBucketsResponseDto[]> {
+    // Convert album filters to search options
+    const searchOptions = this.convertFiltersToSearchOptions(filters, auth.user.id);
+
+    // Get all matching assets
+    const searchResult = await this.searchRepository.searchMetadata(
+      { page: 1, size: 50000 }, // Large page size to get all matching assets
+      { ...searchOptions, orderDirection: dto.order === 'asc' ? 'asc' : 'desc' },
+    );
+
+    // Group assets by time bucket
+    const buckets = new Map<string, number>();
+
+    for (const asset of searchResult.items) {
+      const assetDate = new Date(asset.fileCreatedAt || asset.localDateTime);
+      // Create time bucket in YYYY-MM format
+      const timeBucket = `${assetDate.getFullYear()}-${String(assetDate.getMonth() + 1).padStart(2, '0')}-01`;
+      buckets.set(timeBucket, (buckets.get(timeBucket) || 0) + 1);
+    }
+
+    // Convert to response format and sort
+    return Array.from(buckets.entries())
+      .map(([timeBucket, count]) => ({ timeBucket, count }))
+      .sort((a, b) => b.timeBucket.localeCompare(a.timeBucket)); // Newest first
+  }
+
+  private async getTimeBucketForDynamicAlbum(auth: AuthDto, dto: TimeBucketAssetDto, filters: any): Promise<string> {
+    // Convert album filters to search options
+    const searchOptions = this.convertFiltersToSearchOptions(filters, auth.user.id);
+
+    // Get all matching assets
+    const searchResult = await this.searchRepository.searchMetadata(
+      { page: 1, size: 50000 }, // Large page size to get all matching assets
+      { ...searchOptions, orderDirection: dto.order === 'asc' ? 'asc' : 'desc' },
+    );
+
+    // Filter assets by the specific time bucket
+    const [year, month] = dto.timeBucket.split('-').map(Number);
+    const startDate = new Date(year, month - 1, 1);
+    const endDate = new Date(year, month, 0, 23, 59, 59, 999);
+
+    const bucketAssets = searchResult.items.filter((asset: any) => {
+      const assetDate = new Date(asset.fileCreatedAt || asset.localDateTime);
+      return assetDate >= startDate && assetDate <= endDate;
+    });
+
+    // Format the response to match AssetRepository.getTimeBucket structure
+    // This needs to be in the same aggregated array format
+    const aggregatedResponse = {
+      id: bucketAssets.map((asset: any) => asset.id),
+      ownerId: bucketAssets.map((asset: any) => asset.ownerId),
+      visibility: bucketAssets.map((asset: any) => asset.visibility || 'TIMELINE'),
+      isFavorite: bucketAssets.map((asset: any) => asset.isFavorite || false),
+      isImage: bucketAssets.map((asset: any) => asset.type === 'IMAGE'),
+      isTrashed: bucketAssets.map(() => false), // Dynamic album assets are never trashed
+      thumbhash: bucketAssets.map((asset: any) => (asset.thumbhash ? hexOrBufferToBase64(asset.thumbhash) : null)),
+      fileCreatedAt: bucketAssets.map((asset: any) => asset.fileCreatedAt || asset.localDateTime),
+      localOffsetHours: bucketAssets.map((asset: any) => {
+        // Calculate offset hours from fileCreatedAt and localDateTime if available
+        if (asset.fileCreatedAt && asset.localDateTime) {
+          const fileDate = new Date(asset.fileCreatedAt);
+          const localDate = new Date(asset.localDateTime);
+          return (localDate.getTime() - fileDate.getTime()) / (1000 * 60 * 60);
+        }
+        return 0; // Default offset
+      }),
+      duration: bucketAssets.map((asset: any) => asset.duration || null),
+      city: bucketAssets.map((asset: any) => asset.exifInfo?.city || null),
+      country: bucketAssets.map((asset: any) => asset.exifInfo?.country || null),
+      projectionType: bucketAssets.map((asset: any) => asset.exifInfo?.projectionType || null),
+      livePhotoVideoId: bucketAssets.map((asset: any) => asset.livePhotoVideoId || null),
+      ratio: bucketAssets.map((asset: any) => {
+        // Calculate aspect ratio from exif info if available
+        if (asset.exifInfo?.exifImageWidth && asset.exifInfo?.exifImageHeight) {
+          // Check for orientation that would swap dimensions
+          const orientation = asset.exifInfo.orientation;
+          const isRotated = ['5', '6', '7', '8', '-90', '90'].includes(String(orientation));
+
+          const width = asset.exifInfo.exifImageWidth;
+          const height = asset.exifInfo.exifImageHeight;
+
+          if (width === 0 || height === 0) return 1;
+
+          if (isRotated) {
+            return Math.round((height / width) * 1000) / 1000;
+          } else {
+            return Math.round((width / height) * 1000) / 1000;
+          }
+        }
+        return 1; // Default ratio
+      }),
+      status: bucketAssets.map((asset: any) => asset.status || 'AVAILABLE'),
+      ...(dto.withStacked && {
+        stack: bucketAssets.map((asset: any) => {
+          if (asset.stackId && asset.stackCount) {
+            return [asset.stackId, String(asset.stackCount)];
+          }
+          return null;
+        }),
+      }),
+    };
+
+    return JSON.stringify(aggregatedResponse);
+  }
+
+  /**
+   * Convert dynamic album filters to search options for SearchRepository
+   */
+  private convertFiltersToSearchOptions(filters: any, userId: string): any {
+    const searchOptions: any = {
+      userIds: [userId],
+      withDeleted: false,
+    };
+
+    // Handle the actual filter structure: {tags: [...], operator: "and", ...}
+    if (filters.tags && Array.isArray(filters.tags)) {
+      searchOptions.tagIds = filters.tags;
+      // Include the operator for tag filtering
+      if (filters.operator) {
+        searchOptions.tagOperator = filters.operator;
+      }
+    }
+
+    if (filters.people && Array.isArray(filters.people)) {
+      searchOptions.personIds = filters.people;
+    }
+
+    if (filters.location) {
+      if (typeof filters.location === 'string') {
+        searchOptions.city = filters.location;
+      } else if (typeof filters.location === 'object') {
+        if (filters.location.city) searchOptions.city = filters.location.city;
+        if (filters.location.state) searchOptions.state = filters.location.state;
+        if (filters.location.country) searchOptions.country = filters.location.country;
+      }
+    }
+
+    if (filters.dateRange && typeof filters.dateRange === 'object') {
+      if (filters.dateRange.start) {
+        searchOptions.takenAfter = new Date(filters.dateRange.start);
+      }
+      if (filters.dateRange.end) {
+        searchOptions.takenBefore = new Date(filters.dateRange.end);
+      }
+    }
+
+    if (filters.assetType) {
+      if (filters.assetType === 'IMAGE' || filters.assetType === 'VIDEO') {
+        searchOptions.type = filters.assetType;
+      }
+    }
+
+    if (filters.metadata && typeof filters.metadata === 'object') {
+      if (filters.metadata.isFavorite !== undefined) {
+        searchOptions.isFavorite = filters.metadata.isFavorite;
+      }
+      if (filters.metadata.make) searchOptions.make = filters.metadata.make;
+      if (filters.metadata.model) searchOptions.model = filters.metadata.model;
+      if (filters.metadata.lensModel) searchOptions.lensModel = filters.metadata.lensModel;
+      if (filters.metadata.rating !== undefined) searchOptions.rating = filters.metadata.rating;
+    }
+
+    return searchOptions;
+  }
+
   private async buildTimeBucketOptions(auth: AuthDto, dto: TimeBucketDto): Promise<TimeBucketOptions> {
     const { userId, ...options } = dto;
     let userIds: string[] | undefined = undefined;
diff --git a/server/src/utils/access.ts b/server/src/utils/access.ts
index b639643b6..6dfd574ca 100644
--- a/server/src/utils/access.ts
+++ b/server/src/utils/access.ts
@@ -96,6 +96,10 @@ const checkSharedLinkAccess = async (
       return sharedLink.allowUpload ? await access.album.checkSharedLinkAccess(sharedLinkId, ids) : new Set();
     }
 
+    case Permission.TIMELINE_READ: {
+      return await access.asset.checkSharedLinkAccess(sharedLinkId, ids);
+    }
+
     default: {
       return new Set<string>();
     }
diff --git a/server/src/utils/database.ts b/server/src/utils/database.ts
index 191e02eb6..232a02533 100644
--- a/server/src/utils/database.ts
+++ b/server/src/utils/database.ts
@@ -241,19 +241,33 @@ export function inAlbums<O>(qb: SelectQueryBuilder<DB, 'assets', O>, albumIds: s
   );
 }
 
-export function hasTags<O>(qb: SelectQueryBuilder<DB, 'assets', O>, tagIds: string[]) {
-  return qb.innerJoin(
-    (eb) =>
-      eb
-        .selectFrom('tag_asset')
-        .select('assetsId')
-        .innerJoin('tags_closure', 'tag_asset.tagsId', 'tags_closure.id_descendant')
-        .where('tags_closure.id_ancestor', '=', anyUuid(tagIds))
-        .groupBy('assetsId')
-        .having((eb) => eb.fn.count('tags_closure.id_ancestor').distinct(), '>=', tagIds.length)
-        .as('has_tags'),
-    (join) => join.onRef('has_tags.assetsId', '=', 'assets.id'),
-  );
+export function hasTags<O>(qb: SelectQueryBuilder<DB, 'assets', O>, tagIds: string[], operator: 'and' | 'or' = 'and') {
+  if (operator === 'and') {
+    // All tags must be present (existing logic)
+    return qb.innerJoin(
+      (eb) =>
+        eb
+          .selectFrom('tag_asset')
+          .select('assetsId')
+          .innerJoin('tags_closure', 'tag_asset.tagsId', 'tags_closure.id_descendant')
+          .where('tags_closure.id_ancestor', '=', anyUuid(tagIds))
+          .groupBy('assetsId')
+          .having((eb) => eb.fn.count('tags_closure.id_ancestor').distinct(), '>=', tagIds.length)
+          .as('has_tags'),
+      (join) => join.onRef('has_tags.assetsId', '=', 'assets.id'),
+    );
+  } else {
+    // Any tag can be present (OR logic)
+    return qb.where((eb) =>
+      eb.exists(
+        eb
+          .selectFrom('tag_asset')
+          .innerJoin('tags_closure', 'tag_asset.tagsId', 'tags_closure.id_descendant')
+          .whereRef('tag_asset.assetsId', '=', 'assets.id')
+          .where('tags_closure.id_ancestor', 'in', tagIds),
+      ),
+    );
+  }
 }
 
 export function withOwner(eb: ExpressionBuilder<DB, 'assets'>) {
@@ -306,7 +320,9 @@ export function searchAssetBuilder(kysely: Kysely<DB>, options: AssetSearchBuild
     .selectFrom('assets')
     .where('assets.visibility', '=', visibility)
     .$if(!!options.albumIds && options.albumIds.length > 0, (qb) => inAlbums(qb, options.albumIds!))
-    .$if(!!options.tagIds && options.tagIds.length > 0, (qb) => hasTags(qb, options.tagIds!))
+    .$if(!!options.tagIds && options.tagIds.length > 0, (qb) =>
+      hasTags(qb, options.tagIds!, options.tagOperator || 'and'),
+    )
     .$if(!!options.personIds && options.personIds.length > 0, (qb) => hasPeople(qb, options.personIds!))
     .$if(!!options.createdBefore, (qb) => qb.where('assets.createdAt', '<=', options.createdBefore!))
     .$if(!!options.createdAfter, (qb) => qb.where('assets.createdAt', '>=', options.createdAfter!))
diff --git a/server/src/utils/filter.util.ts b/server/src/utils/filter.util.ts
new file mode 100644
index 000000000..545bd9658
--- /dev/null
+++ b/server/src/utils/filter.util.ts
@@ -0,0 +1,193 @@
+import { AlbumFilterType } from 'src/enum';
+
+/**
+ * Album filter structure for type safety
+ */
+export interface AlbumFilter {
+  type: AlbumFilterType;
+  value: any;
+}
+
+/**
+ * Utility functions for processing album filters
+ */
+export class FilterUtil {
+  /**
+   * Filter assets by time bucket (year-month)
+   * @param assets Array of assets to filter
+   * @param timeBucket Time bucket in format YYYY-MM-DD
+   * @returns Filtered assets that fall within the time bucket
+   */
+  static filterAssetsByTimeBucket<T extends { fileCreatedAt?: Date | string }>(assets: T[], timeBucket: string): T[] {
+    // Parse the time bucket (format: YYYY-MM-DD)
+    const [year, month] = timeBucket.split('-').map(Number);
+    const startDate = new Date(year, month - 1, 1); // First day of the month
+    const endDate = new Date(year, month, 0); // Last day of the month
+
+    // Filter assets by the time bucket
+    return assets.filter((asset) => {
+      if (!asset.fileCreatedAt) return false;
+      const assetDate = new Date(asset.fileCreatedAt);
+      return assetDate >= startDate && assetDate <= endDate;
+    });
+  }
+
+  /**
+   * Validate album filters
+   * @param filters Array of album filters to validate
+   * @returns Array of validation errors (empty if valid)
+   */
+  static validateFilters(filters: AlbumFilter[]): string[] {
+    const errors: string[] = [];
+
+    if (!filters || filters.length === 0) {
+      return errors;
+    }
+
+    for (const filter of filters) {
+      if (!filter.type) {
+        errors.push('Filter type is required');
+        continue;
+      }
+
+      if (!filter.value) {
+        errors.push(`Filter value is required for type: ${filter.type}`);
+        continue;
+      }
+
+      // Validate specific filter types
+      switch (filter.type) {
+        case AlbumFilterType.TAG:
+          if (typeof filter.value !== 'string' && !Array.isArray(filter.value)) {
+            errors.push('Tag filter value must be a string or array of strings');
+          }
+          break;
+        case AlbumFilterType.PERSON:
+          if (typeof filter.value !== 'string' && !Array.isArray(filter.value)) {
+            errors.push('Person filter value must be a string or array of strings');
+          }
+          break;
+        case AlbumFilterType.LOCATION:
+          if (typeof filter.value !== 'string') {
+            errors.push('Location filter value must be a string');
+          }
+          break;
+        case AlbumFilterType.DATE_RANGE:
+          if (typeof filter.value !== 'object' || !filter.value.start || !filter.value.end) {
+            errors.push('Date range filter value must be an object with start and end dates');
+          }
+          break;
+        case AlbumFilterType.ASSET_TYPE:
+          if (!['IMAGE', 'VIDEO'].includes(filter.value as string)) {
+            errors.push('Asset type filter value must be either IMAGE or VIDEO');
+          }
+          break;
+        case AlbumFilterType.METADATA:
+          if (typeof filter.value !== 'object') {
+            errors.push('Metadata filter value must be an object');
+          }
+          break;
+        default:
+          errors.push(`Unknown filter type: ${filter.type}`);
+      }
+    }
+
+    return errors;
+  }
+
+  /**
+   * Normalize filter values for consistent processing
+   * @param filters Array of album filters to normalize
+   * @returns Array of normalized filters
+   */
+  static normalizeFilters(filters: AlbumFilter[]): AlbumFilter[] {
+    if (!filters || filters.length === 0) {
+      return [];
+    }
+
+    return filters.map((filter) => {
+      const normalized = { ...filter };
+
+      // Normalize string arrays to ensure consistent format
+      if (filter.type === AlbumFilterType.TAG || filter.type === AlbumFilterType.PERSON) {
+        if (typeof filter.value === 'string') {
+          normalized.value = [filter.value];
+        } else if (Array.isArray(filter.value)) {
+          normalized.value = filter.value.filter((v: any) => v && typeof v === 'string');
+        }
+      }
+
+      // Normalize location values
+      if (filter.type === AlbumFilterType.LOCATION) {
+        if (typeof filter.value === 'string') {
+          normalized.value = filter.value.trim();
+        }
+      }
+
+      // Normalize date ranges
+      if (filter.type === AlbumFilterType.DATE_RANGE && typeof filter.value === 'object') {
+        const dateRange = filter.value as { start?: string; end?: string };
+        if (dateRange.start && dateRange.end) {
+          normalized.value = {
+            start: new Date(dateRange.start).toISOString(),
+            end: new Date(dateRange.end).toISOString(),
+          };
+        }
+      }
+
+      return normalized;
+    });
+  }
+
+  /**
+   * Convert legacy dynamic album filters to new album filter format
+   * @param legacyFilters Array of legacy filters with filterType and filterValue
+   * @returns Array of new album filters
+   */
+  static convertLegacyFilters(legacyFilters: Array<{ filterType: string; filterValue: any }>): AlbumFilter[] {
+    if (!legacyFilters || legacyFilters.length === 0) {
+      return [];
+    }
+
+    return legacyFilters.map((filter) => ({
+      type: filter.filterType as any,
+      value: filter.filterValue,
+    }));
+  }
+
+  /**
+   * Check if filters are equivalent (for deduplication)
+   * @param filter1 First filter
+   * @param filter2 Second filter
+   * @returns True if filters are equivalent
+   */
+  static areFiltersEquivalent(filter1: AlbumFilter, filter2: AlbumFilter): boolean {
+    if (filter1.type !== filter2.type) {
+      return false;
+    }
+
+    // Deep comparison for complex values
+    return JSON.stringify(filter1.value) === JSON.stringify(filter2.value);
+  }
+
+  /**
+   * Remove duplicate filters from an array
+   * @param filters Array of filters to deduplicate
+   * @returns Array of unique filters
+   */
+  static deduplicateFilters(filters: AlbumFilter[]): AlbumFilter[] {
+    if (!filters || filters.length === 0) {
+      return [];
+    }
+
+    const unique: AlbumFilter[] = [];
+
+    for (const filter of filters) {
+      if (!unique.some((existing) => FilterUtil.areFiltersEquivalent(existing, filter))) {
+        unique.push(filter);
+      }
+    }
+
+    return unique;
+  }
+}
diff --git a/server/test/fixtures/album.stub.ts b/server/test/fixtures/album.stub.ts
index fd6a8678a..6e95005f2 100644
--- a/server/test/fixtures/album.stub.ts
+++ b/server/test/fixtures/album.stub.ts
@@ -21,6 +21,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   sharedWithUser: Object.freeze({
     id: 'album-2',
@@ -44,6 +46,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   sharedWithMultiple: Object.freeze({
     id: 'album-3',
@@ -71,6 +75,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   sharedWithAdmin: Object.freeze({
     id: 'album-3',
@@ -94,6 +100,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   oneAsset: Object.freeze({
     id: 'album-4',
@@ -112,6 +120,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   twoAssets: Object.freeze({
     id: 'album-4a',
@@ -130,6 +140,8 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
   emptyWithValidThumbnail: Object.freeze({
     id: 'album-5',
@@ -148,5 +160,7 @@ export const albumStub = {
     isActivityEnabled: true,
     order: AssetOrder.DESC,
     updateId: '42',
+    dynamic: false,
+    filters: null,
   }),
 };
diff --git a/server/test/fixtures/shared-link.stub.ts b/server/test/fixtures/shared-link.stub.ts
index f3096280d..a309f0288 100644
--- a/server/test/fixtures/shared-link.stub.ts
+++ b/server/test/fixtures/shared-link.stub.ts
@@ -100,6 +100,8 @@ const albumResponse: AlbumResponseDto = {
   assetCount: 1,
   isActivityEnabled: true,
   order: AssetOrder.DESC,
+  dynamic: false,
+  filters: null,
 };
 
 export const sharedLinkStub = {
@@ -183,6 +185,8 @@ export const sharedLinkStub = {
       sharedLinks: [],
       isActivityEnabled: true,
       order: AssetOrder.DESC,
+      dynamic: false,
+      filters: null,
       assets: [
         {
           id: 'id_1',
diff --git a/web/src/lib/components/album-page/album-card.svelte b/web/src/lib/components/album-page/album-card.svelte
index b6b44cadf..a2011a422 100644
--- a/web/src/lib/components/album-page/album-card.svelte
+++ b/web/src/lib/components/album-page/album-card.svelte
@@ -5,7 +5,7 @@
   import { getShortDateRange } from '$lib/utils/date-time';
   import type { AlbumResponseDto } from '@immich/sdk';
   import { IconButton } from '@immich/ui';
-  import { mdiDotsVertical } from '@mdi/js';
+  import { mdiDotsVertical, mdiFilterOutline } from '@mdi/js';
   import { t } from 'svelte-i18n';
 
   interface Props {
@@ -31,11 +31,17 @@
     e.preventDefault();
     onShowContextMenu?.(getContextMenuPositionFromEvent(e));
   };
+
+  // Computed properties for dynamic albums
+  let isDynamic = $derived(album?.dynamic === true);
+  let hasFilters = $derived(isDynamic && album?.filters && Object.keys(album.filters).length > 0);
+  let filterCount = $derived(hasFilters ? Object.keys(album.filters).length : 0);
 </script>
 
 <div
   class="group relative rounded-2xl border border-transparent p-5 hover:bg-gray-100 hover:border-gray-200 dark:hover:border-gray-800 dark:hover:bg-gray-900"
   data-testid="album-card"
+  class:dynamic-album={isDynamic}
 >
   {#if onShowContextMenu}
     <div
@@ -56,6 +62,18 @@
     </div>
   {/if}
 
+  <!-- Dynamic album indicator -->
+  {#if isDynamic}
+    <div class="absolute start-3 top-3 z-10" data-testid="dynamic-indicator">
+      <div class="flex items-center gap-1 rounded-full bg-immich-primary/90 px-2 py-1 text-xs text-white backdrop-blur-sm">
+        <svg class="h-3 w-3" viewBox="0 0 24 24" fill="currentColor">
+          <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
+        </svg>
+        <span>{$t('dynamic')}</span>
+      </div>
+    </div>
+  {/if}
+
   <AlbumCover {album} {preload} class="transition-all duration-300 hover:shadow-lg" />
 
   <div class="mt-4">
@@ -96,5 +114,51 @@
         <p>{$t('shared')}</p>
       {/if}
     </span>
+
+    <!-- Description for dynamic albums -->
+    {#if isDynamic && album.description}
+      <p class="line-clamp-2 text-xs text-gray-500 dark:text-gray-400 mt-1">
+        {album.description}
+      </p>
+    {/if}
+
+    <!-- Filter indicators for dynamic albums -->
+    {#if hasFilters}
+      <div class="flex items-center gap-1 mt-2 text-xs text-gray-500 dark:text-gray-400" data-testid="filter-indicator">
+        <IconButton
+          icon={mdiFilterOutline}
+          size="small"
+          color="secondary"
+          variant="ghost"
+          class="!p-0 !w-4 !h-4"
+          aria-label={$t('filters')}
+        />
+        <span>{$t('filters_count', { values: { count: filterCount } })}</span>
+      </div>
+    {/if}
   </div>
 </div>
+
+<style>
+  .dynamic-album {
+    position: relative;
+  }
+  
+  .dynamic-album::before {
+    content: '';
+    position: absolute;
+    top: 0;
+    left: 0;
+    right: 0;
+    bottom: 0;
+    border-radius: 1rem;
+    background: linear-gradient(45deg, transparent, rgba(99, 102, 241, 0.1), transparent);
+    pointer-events: none;
+    opacity: 0;
+    transition: opacity 0.3s ease;
+  }
+  
+  .dynamic-album:hover::before {
+    opacity: 1;
+  }
+</style>
diff --git a/web/src/lib/components/album-page/album-viewer.svelte b/web/src/lib/components/album-page/album-viewer.svelte
index 0866d3855..275e9c0f2 100644
--- a/web/src/lib/components/album-page/album-viewer.svelte
+++ b/web/src/lib/components/album-page/album-viewer.svelte
@@ -107,7 +107,7 @@
       {#snippet trailing()}
         <CastButton />
 
-        {#if sharedLink.allowUpload}
+        {#if sharedLink.allowUpload && !album.dynamic}
           <IconButton
             shape="round"
             color="secondary"
diff --git a/web/src/lib/components/album-page/albums-controls.svelte b/web/src/lib/components/album-page/albums-controls.svelte
index 1fff0c29a..8395c9e9d 100644
--- a/web/src/lib/components/album-page/albums-controls.svelte
+++ b/web/src/lib/components/album-page/albums-controls.svelte
@@ -14,13 +14,13 @@
     type AlbumGroupOptionMetadata,
     type AlbumSortOptionMetadata,
     collapseAllAlbumGroups,
-    createAlbumAndRedirect,
     expandAllAlbumGroups,
     findFilterOption,
     findGroupOptionMetadata,
     findSortOptionMetadata,
     getSelectedAlbumGroupOption,
     groupOptionsMetadata,
+    showCreateAlbumModal,
     sortOptionsMetadata,
   } from '$lib/utils/album-utils';
   import { Button, IconButton, Text } from '@immich/ui';
@@ -130,7 +130,7 @@
 <!-- Create Album -->
 <Button
   leadingIcon={mdiPlusBoxOutline}
-  onclick={() => createAlbumAndRedirect()}
+  onclick={() => showCreateAlbumModal()}
   size="small"
   variant="ghost"
   color="secondary"
diff --git a/web/src/lib/components/shared-components/filter-display.svelte b/web/src/lib/components/shared-components/filter-display.svelte
new file mode 100644
index 000000000..c8b368ba7
--- /dev/null
+++ b/web/src/lib/components/shared-components/filter-display.svelte
@@ -0,0 +1,237 @@
+<script lang="ts">
+  import { getAllTags, type TagResponseDto } from '@immich/sdk';
+  import { onMount } from 'svelte';
+  import { t } from 'svelte-i18n';
+
+  interface Props {
+    filters: any;
+  }
+
+  let { filters }: Props = $props();
+
+  let allTags: TagResponseDto[] = $state([]);
+  let tagMap = $derived(Object.fromEntries(allTags.map((tag) => [tag.id, tag])));
+
+  onMount(async () => {
+    allTags = await getAllTags();
+  });
+</script>
+
+{#if filters && typeof filters === 'object'}
+  <div class="space-y-2">
+    <!-- Tag Filter -->
+    {#if filters.tags && Array.isArray(filters.tags) && filters.tags.length > 0}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-400 text-xs font-medium"
+        >
+          1
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_tag')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="flex items-center gap-2">
+              <span class="font-medium">{$t(filters.operator === 'and' ? 'operator_and' : 'operator_or')}:</span>
+              <span>{filters.tags.length} {$t('tags')}</span>
+            </div>
+            {#if filters.tags.length > 0}
+              <div class="text-xs text-gray-400 dark:text-gray-500">
+                {filters.tags
+                  .slice(0, 3)
+                  .map((tagId: string) => tagMap[tagId]?.value || tagId)
+                  .join(', ')}{filters.tags.length > 3 ? '...' : ''}
+              </div>
+            {/if}
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Person Filter -->
+    {#if filters.people && Array.isArray(filters.people) && filters.people.length > 0}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-400 text-xs font-medium"
+        >
+          2
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_person')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="flex items-center gap-2">
+              <span class="font-medium">{$t(filters.operator === 'and' ? 'operator_and' : 'operator_or')}:</span>
+              <span>{filters.people.length} {$t('people')}</span>
+            </div>
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Location Filter -->
+    {#if filters.location}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-purple-100 text-purple-600 dark:bg-purple-900 dark:text-purple-400 text-xs font-medium"
+        >
+          3
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_location')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            {#if typeof filters.location === 'string'}
+              <div class="flex items-center gap-2">
+                <span class="font-medium">{$t('location')}:</span>
+                <span>{filters.location}</span>
+              </div>
+            {:else if typeof filters.location === 'object'}
+              <div class="space-y-1">
+                {#if filters.location.city}
+                  <div class="flex items-center gap-2">
+                    <span class="font-medium">{$t('city')}:</span>
+                    <span>{filters.location.city}</span>
+                  </div>
+                {/if}
+                {#if filters.location.state}
+                  <div class="flex items-center gap-2">
+                    <span class="font-medium">{$t('state')}:</span>
+                    <span>{filters.location.state}</span>
+                  </div>
+                {/if}
+                {#if filters.location.country}
+                  <div class="flex items-center gap-2">
+                    <span class="font-medium">{$t('country')}:</span>
+                    <span>{filters.location.country}</span>
+                  </div>
+                {/if}
+              </div>
+            {/if}
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Date Range Filter -->
+    {#if filters.dateRange}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-orange-100 text-orange-600 dark:bg-orange-900 dark:text-orange-400 text-xs font-medium"
+        >
+          4
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_date_range')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="space-y-1">
+              {#if filters.dateRange.start && filters.dateRange.end}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">{$t('date_range')}:</span>
+                  <span
+                    >{new Date(filters.dateRange.start).toLocaleDateString()} - {new Date(
+                      filters.dateRange.end,
+                    ).toLocaleDateString()}</span
+                  >
+                </div>
+              {:else if filters.dateRange.start}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">From:</span>
+                  <span>{new Date(filters.dateRange.start).toLocaleDateString()}</span>
+                </div>
+              {:else if filters.dateRange.end}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">Until:</span>
+                  <span>{new Date(filters.dateRange.end).toLocaleDateString()}</span>
+                </div>
+              {/if}
+            </div>
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Asset Type Filter -->
+    {#if filters.assetType}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-red-100 text-red-600 dark:bg-red-900 dark:text-red-400 text-xs font-medium"
+        >
+          5
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_asset_type')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="space-y-1">
+              <div class="flex items-center gap-2">
+                <span class="font-medium">{$t('asset_type')}:</span>
+                <span>{$t(filters.assetType === 'IMAGE' ? 'images' : 'videos')}</span>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+    {/if}
+
+    <!-- Metadata Filter -->
+    {#if filters.metadata}
+      <div class="flex items-start gap-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-700">
+        <div
+          class="flex h-6 w-6 items-center justify-center rounded-full bg-indigo-100 text-indigo-600 dark:bg-indigo-900 dark:text-indigo-400 text-xs font-medium"
+        >
+          6
+        </div>
+
+        <div class="flex-1 min-w-0">
+          <div class="text-sm font-medium text-gray-900 dark:text-white mb-1">
+            {$t('filter_type_metadata')}
+          </div>
+
+          <div class="text-xs text-gray-500 dark:text-gray-400">
+            <div class="space-y-1">
+              {#if filters.metadata.isFavorite !== undefined}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">{$t('favorites')}:</span>
+                  <span>{filters.metadata.isFavorite ? $t('yes') : $t('no')}</span>
+                </div>
+              {/if}
+              {#if filters.metadata.make}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">{$t('make')}:</span>
+                  <span>{filters.metadata.make}</span>
+                </div>
+              {/if}
+              {#if filters.metadata.model}
+                <div class="flex items-center gap-2">
+                  <span class="font-medium">{$t('model')}:</span>
+                  <span>{filters.metadata.model}</span>
+                </div>
+              {/if}
+            </div>
+          </div>
+        </div>
+      </div>
+    {/if}
+  </div>
+{:else}
+  <p class="text-sm text-gray-500 dark:text-gray-400">
+    {$t('no_filters_configured')}
+  </p>
+{/if}
diff --git a/web/src/lib/components/shared-components/filter-operator-selector.svelte b/web/src/lib/components/shared-components/filter-operator-selector.svelte
new file mode 100644
index 000000000..f808fd248
--- /dev/null
+++ b/web/src/lib/components/shared-components/filter-operator-selector.svelte
@@ -0,0 +1,34 @@
+<script lang="ts">
+  import SettingDropdown from '$lib/components/shared-components/settings/setting-dropdown.svelte';
+  import { mdiArrowUpThin, mdiArrowDownThin } from '@mdi/js';
+  import { t } from 'svelte-i18n';
+  import type { RenderedOption } from '../elements/dropdown.svelte';
+
+  interface Props {
+    selectedOperator: 'and' | 'or';
+    onOperatorChange: (operator: 'and' | 'or') => void;
+  }
+
+  let { selectedOperator = $bindable(), onOperatorChange }: Props = $props();
+
+  // Operator options for the dropdown
+  const operatorOptions: Record<'and' | 'or', RenderedOption> = {
+    and: { icon: mdiArrowUpThin, title: $t('operator_and') },
+    or: { icon: mdiArrowDownThin, title: $t('operator_or') },
+  };
+</script>
+
+<div class="flex flex-col gap-2">
+  <SettingDropdown
+    title={$t('filter_operator')}
+    subtitle={$t('filter_operator_description')}
+    options={Object.values(operatorOptions)}
+    selectedOption={operatorOptions[selectedOperator]}
+    onToggle={(option) => {
+      const newOperator = Object.keys(operatorOptions).find(key => operatorOptions[key as 'and' | 'or'] === option) as 'and' | 'or';
+      if (newOperator) {
+        onOperatorChange(newOperator);
+      }
+    }}
+  />
+</div> 
\ No newline at end of file
diff --git a/web/src/lib/components/shared-components/tag-selector.svelte b/web/src/lib/components/shared-components/tag-selector.svelte
new file mode 100644
index 000000000..43a07dc14
--- /dev/null
+++ b/web/src/lib/components/shared-components/tag-selector.svelte
@@ -0,0 +1,91 @@
+<script lang="ts">
+  import Icon from '$lib/components/elements/icon.svelte';
+  import Combobox, { type ComboBoxOption } from '$lib/components/shared-components/combobox.svelte';
+  import { getAllTags, type TagResponseDto } from '@immich/sdk';
+  import { mdiClose } from '@mdi/js';
+  import { onMount } from 'svelte';
+  import { t } from 'svelte-i18n';
+  import { SvelteSet } from 'svelte/reactivity';
+
+  interface Props {
+    selectedTagIds: SvelteSet<string>;
+    label?: string;
+    placeholder?: string;
+    showLabel?: boolean;
+    forceFocus?: boolean;
+  }
+
+  let { 
+    selectedTagIds = $bindable(), 
+    label = $t('tags'),
+    placeholder = $t('search_tags'),
+    showLabel = true,
+    forceFocus = false
+  }: Props = $props();
+
+  let allTags: TagResponseDto[] = $state([]);
+  let tagMap = $derived(Object.fromEntries(allTags.map((tag) => [tag.id, tag])));
+
+  onMount(async () => {
+    allTags = await getAllTags();
+  });
+
+  const handleSelect = (option?: ComboBoxOption) => {
+    if (!option || !option.id) {
+      return;
+    }
+
+    selectedTagIds.add(option.value);
+  };
+
+  const handleRemove = (tagId: string) => {
+    selectedTagIds.delete(tagId);
+  };
+</script>
+
+<div class="my-4 flex flex-col gap-2">
+  <Combobox
+    onSelect={handleSelect}
+    label={showLabel ? label : ''}
+    hideLabel={!showLabel}
+    defaultFirstOption
+    {forceFocus}
+    options={allTags.map((tag) => ({ id: tag.id, label: tag.value, value: tag.id }))}
+    {placeholder}
+  />
+</div>
+
+<!-- Selected Tags Display -->
+{#if selectedTagIds.size > 0}
+  <section class="flex flex-wrap pt-2 gap-1">
+    {#each selectedTagIds as tagId (tagId)}
+      {@const tag = tagMap[tagId]}
+      {#if tag}
+        <div class="flex group transition-all">
+          <span
+            class="inline-block h-min whitespace-nowrap ps-3 pe-1 group-hover:ps-3 py-1 text-center align-baseline leading-none text-gray-100 dark:text-immich-dark-gray bg-primary rounded-s-full hover:bg-immich-primary/80 dark:hover:bg-immich-dark-primary/80 transition-all"
+          >
+            <p class="text-sm">
+              {tag.value}
+            </p>
+          </span>
+
+          <button
+            type="button"
+            class="text-gray-100 dark:text-immich-dark-gray bg-immich-primary/95 dark:bg-immich-dark-primary/95 rounded-e-full place-items-center place-content-center pe-2 ps-1 py-1 hover:bg-immich-primary/80 dark:hover:bg-immich-dark-primary/80 transition-all"
+            title={$t('remove_tag')}
+            onclick={() => handleRemove(tagId)}
+          >
+            <Icon path={mdiClose} />
+          </button>
+        </div>
+      {/if}
+    {/each}
+  </section>
+{/if}
+
+{#if selectedTagIds.size === 0}
+  <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
+    {$t('select_tags_for_dynamic_album')}
+  </p>
+{/if} 
\ No newline at end of file
diff --git a/web/src/lib/managers/timeline-manager/internal/load-support.svelte.ts b/web/src/lib/managers/timeline-manager/internal/load-support.svelte.ts
index ebe8acbec..3546f01ad 100644
--- a/web/src/lib/managers/timeline-manager/internal/load-support.svelte.ts
+++ b/web/src/lib/managers/timeline-manager/internal/load-support.svelte.ts
@@ -19,6 +19,9 @@ export async function loadFromTimeBuckets(
 
   const timeBucket = toISOYearMonthUTC(monthGroup.yearMonth);
   const key = authManager.key;
+
+  // Unified timeline fetch for both regular and dynamic albums
+  // The enhanced backend now handles dynamic filtering automatically
   const bucketResponse = await getTimeBucket(
     {
       ...options,
diff --git a/web/src/lib/managers/timeline-manager/types.ts b/web/src/lib/managers/timeline-manager/types.ts
index 8e5523758..3de57705d 100644
--- a/web/src/lib/managers/timeline-manager/types.ts
+++ b/web/src/lib/managers/timeline-manager/types.ts
@@ -6,6 +6,7 @@ export type AssetApiGetTimeBucketsRequest = Parameters<typeof import('@immich/sd
 export type TimelineManagerOptions = Omit<AssetApiGetTimeBucketsRequest, 'size'> & {
   timelineAlbumId?: string;
   deferInit?: boolean;
+  _forceReload?: number;
 };
 
 export type AssetDescriptor = { id: string };
diff --git a/web/src/lib/modals/CreateAlbumModal.svelte b/web/src/lib/modals/CreateAlbumModal.svelte
new file mode 100644
index 000000000..a631753ce
--- /dev/null
+++ b/web/src/lib/modals/CreateAlbumModal.svelte
@@ -0,0 +1,211 @@
+<script lang="ts">
+  import type { RenderedOption } from '$lib/components/elements/dropdown.svelte';
+  import {
+    notificationController,
+    NotificationType,
+  } from '$lib/components/shared-components/notification/notification';
+  import SettingDropdown from '$lib/components/shared-components/settings/setting-dropdown.svelte';
+  import TagSelector from '$lib/components/shared-components/tag-selector.svelte';
+  import { handleError } from '$lib/utils/handle-error';
+  import { createAlbum, type AlbumResponseDto } from '@immich/sdk';
+  import { Button, HStack, Modal, ModalBody, ModalFooter } from '@immich/ui';
+  import { mdiFilter, mdiFolderOutline, mdiMultiplication, mdiPlus } from '@mdi/js';
+  import { t } from 'svelte-i18n';
+  import { SvelteSet } from 'svelte/reactivity';
+
+  interface Props {
+    onClose: (album?: AlbumResponseDto) => void;
+    shared?: boolean;
+    assetIds?: string[];
+  }
+
+  let { onClose, shared = false, assetIds = [] }: Props = $props();
+
+  let albumName = $state('');
+  let albumDescription = $state('');
+  let isDynamic = $state(false);
+  let selectedTagIds = new SvelteSet<string>();
+  let selectedOperator: 'and' | 'or' = $state('and');
+  let isSubmitting = $state(false);
+
+  // Operator options for the dropdown
+  const operatorOptions: Record<'and' | 'or', RenderedOption> = {
+    and: { icon: mdiMultiplication, title: $t('operator_and') },
+    or: { icon: mdiPlus, title: $t('operator_or') },
+  };
+
+  // Form validation
+  let isValidRegularAlbum = $derived(!isSubmitting && albumName.trim().length > 0);
+  let isValidDynamicAlbum = $derived(!isSubmitting && albumName.trim().length > 0 && selectedTagIds.size > 0);
+  let disabled = $derived(isDynamic ? !isValidDynamicAlbum : !isValidRegularAlbum);
+
+  const handleSubmit = async () => {
+    if (!albumName.trim()) {
+      return;
+    }
+
+    if (isDynamic && selectedTagIds.size === 0) {
+      return;
+    }
+
+    isSubmitting = true;
+    try {
+      let createAlbumDto: any = {
+        albumName: albumName.trim(),
+        description: albumDescription.trim() || undefined,
+        dynamic: isDynamic,
+      };
+
+      // Add asset IDs for regular albums
+      if (!isDynamic && assetIds.length > 0) {
+        createAlbumDto.assetIds = assetIds;
+      }
+
+      // Add filters for dynamic albums
+      if (isDynamic) {
+        createAlbumDto.filters = {
+          tags: [...selectedTagIds],
+          operator: selectedOperator,
+        };
+      }
+
+      const album = await createAlbum({ createAlbumDto });
+
+      notificationController.show({
+        message: isDynamic
+          ? $t('dynamic_album_created', { values: { album: album.albumName } })
+          : $t('album_created_success', { values: { album: album.albumName } }),
+        type: NotificationType.Info,
+      });
+
+      onClose(album);
+    } catch (error) {
+      handleError(error, isDynamic ? $t('errors.failed_to_create_dynamic_album') : $t('errors.failed_to_create_album'));
+    } finally {
+      isSubmitting = false;
+    }
+  };
+
+  const onsubmit = async (event: Event) => {
+    event.preventDefault();
+    await handleSubmit();
+  };
+</script>
+
+<Modal
+  size="medium"
+  title={isDynamic ? $t('create_dynamic_album') : $t('create_album')}
+  icon={mdiFolderOutline}
+  {onClose}
+>
+  <ModalBody>
+    <div class="text-immich-primary dark:text-immich-dark-primary">
+      <p class="text-sm dark:text-immich-dark-fg mb-4">
+        {isDynamic ? $t('create_dynamic_album_description') : $t('create_album_description')}
+      </p>
+    </div>
+
+    <form {onsubmit} autocomplete="off" id="create-album-form">
+      <!-- Album Type Toggle -->
+      <div class="my-4 flex flex-col gap-2">
+        <label class="immich-form-label">{$t('album_type')}</label>
+        <div class="flex gap-2">
+          <Button
+            size="small"
+            variant={!isDynamic ? 'filled' : 'ghost'}
+            color={!isDynamic ? 'primary' : 'secondary'}
+            leadingIcon={mdiFolderOutline}
+            onclick={() => (isDynamic = false)}
+          >
+            {$t('regular_album')}
+          </Button>
+          <Button
+            size="small"
+            variant={isDynamic ? 'filled' : 'ghost'}
+            color={isDynamic ? 'primary' : 'secondary'}
+            leadingIcon={mdiFilter}
+            onclick={() => (isDynamic = true)}
+          >
+            {$t('dynamic_album')}
+          </Button>
+        </div>
+        <p class="text-xs text-gray-500 dark:text-gray-400">
+          {isDynamic ? $t('dynamic_album_type_description') : $t('regular_album_type_description')}
+        </p>
+      </div>
+
+      <!-- Album Name -->
+      <div class="my-4 flex flex-col gap-2">
+        <label class="immich-form-label" for="album-name">{$t('name')}</label>
+        <input
+          class="immich-form-input"
+          id="album-name"
+          type="text"
+          bind:value={albumName}
+          placeholder={$t('enter_album_name')}
+          required
+          autofocus
+        />
+      </div>
+
+      <!-- Album Description -->
+      <div class="my-4 flex flex-col gap-2">
+        <label class="immich-form-label" for="album-description">{$t('description')}</label>
+        <textarea
+          class="immich-form-input"
+          id="album-description"
+          bind:value={albumDescription}
+          placeholder={$t('enter_album_description')}
+          rows="3"
+        />
+      </div>
+
+      <!-- Dynamic Album Filters -->
+      {#if isDynamic}
+        <div class="my-4 flex flex-col gap-2">
+          <TagSelector bind:selectedTagIds />
+        </div>
+
+        <!-- Operator Selection -->
+        {#if selectedTagIds.size > 1}
+          <div class="my-4 flex flex-col gap-2">
+            <SettingDropdown
+              title={$t('filter_operator')}
+              subtitle={$t('filter_operator_description')}
+              options={Object.values(operatorOptions)}
+              selectedOption={operatorOptions[selectedOperator]}
+              onToggle={(option) => {
+                const newOperator = Object.keys(operatorOptions).find(
+                  (key) => operatorOptions[key as 'and' | 'or'] === option,
+                ) as 'and' | 'or';
+                if (newOperator) {
+                  selectedOperator = newOperator;
+                }
+              }}
+            />
+          </div>
+        {/if}
+      {/if}
+
+      <!-- Asset Count Info for Regular Albums -->
+      {#if !isDynamic && assetIds.length > 0}
+        <div class="my-4 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
+          <p class="text-sm text-gray-600 dark:text-gray-400">
+            {$t('assets_will_be_added', { values: { count: assetIds.length } })}
+          </p>
+        </div>
+      {/if}
+    </form>
+  </ModalBody>
+
+  <ModalFooter>
+    <HStack fullWidth>
+      <Button shape="round" color="secondary" fullWidth onclick={() => onClose()}>
+        {$t('cancel')}
+      </Button>
+      <Button type="submit" shape="round" fullWidth form="create-album-form" {disabled}>
+        {$t('create')}
+      </Button>
+    </HStack>
+  </ModalFooter>
+</Modal>
diff --git a/web/src/lib/modals/DynamicAlbumFiltersModal.svelte b/web/src/lib/modals/DynamicAlbumFiltersModal.svelte
new file mode 100644
index 000000000..07de46e73
--- /dev/null
+++ b/web/src/lib/modals/DynamicAlbumFiltersModal.svelte
@@ -0,0 +1,128 @@
+<script lang="ts">
+  import SettingDropdown from '$lib/components/shared-components/settings/setting-dropdown.svelte';
+  import TagSelector from '$lib/components/shared-components/tag-selector.svelte';
+  import { handleError } from '$lib/utils/handle-error';
+  import { updateAlbumInfo, type AlbumResponseDto } from '@immich/sdk';
+  import { Button, HStack, Modal, ModalBody, ModalFooter } from '@immich/ui';
+  import { mdiArrowDownThin, mdiArrowUpThin } from '@mdi/js';
+  import { t } from 'svelte-i18n';
+  import { SvelteSet } from 'svelte/reactivity';
+  import type { RenderedOption } from '../components/elements/dropdown.svelte';
+  import { notificationController, NotificationType } from '../components/shared-components/notification/notification';
+
+  interface Props {
+    album: AlbumResponseDto;
+    onClose: (result?: { action: 'updated'; album: AlbumResponseDto }) => void;
+  }
+
+  let { album, onClose }: Props = $props();
+
+  let selectedTagIds = $state(new SvelteSet<string>());
+  let selectedOperator: 'and' | 'or' = $state('and');
+  let isSubmitting = $state(false);
+
+  // Operator options for the dropdown
+  const operatorOptions: Record<'and' | 'or', RenderedOption> = {
+    and: { icon: mdiArrowUpThin, title: $t('operator_and') },
+    or: { icon: mdiArrowDownThin, title: $t('operator_or') },
+  };
+
+  // Pre-populate selected tags and operator from existing filters
+  $effect(() => {
+    if (album.filters && typeof album.filters === 'object') {
+      // Handle flat filter structure: {tags: [...], operator: "and", ...}
+      const filters = album.filters as any;
+      if (filters.tags && Array.isArray(filters.tags)) {
+        // Clear existing tags and add new ones
+        selectedTagIds.clear();
+        for (const tagId of filters.tags) {
+          selectedTagIds.add(tagId);
+        }
+      }
+      // Set the operator from existing filter
+      if (filters.operator) {
+        selectedOperator = filters.operator as 'and' | 'or';
+      }
+    }
+  });
+
+  const handleSubmit = async () => {
+    if (selectedTagIds.size === 0) {
+      return;
+    }
+
+    isSubmitting = true;
+    try {
+      const updatedAlbum = await updateAlbumInfo({
+        id: album.id,
+        updateAlbumDto: {
+          filters: {
+            tags: [...selectedTagIds],
+            operator: selectedOperator,
+          },
+        },
+      });
+
+      notificationController.show({
+        message: $t('album_updated', { values: { album: updatedAlbum.albumName } }),
+        type: NotificationType.Info,
+      });
+
+      onClose({ action: 'updated', album: updatedAlbum });
+    } catch (error) {
+      handleError(error, $t('errors.unable_to_save_album'));
+    } finally {
+      isSubmitting = false;
+    }
+  };
+
+  const onsubmit = async (event: Event) => {
+    event.preventDefault();
+    await handleSubmit();
+  };
+
+  let disabled = $derived(selectedTagIds.size === 0 || isSubmitting);
+</script>
+
+<Modal title={$t('filters')} onClose={() => onClose()} size="medium">
+  <form id="edit-dynamic-album-filters-form" {onsubmit}>
+    <ModalBody>
+      <!-- Dynamic Album Filters -->
+      <div class="my-4 flex flex-col gap-2">
+        <label class="immich-form-label" for="tag-selector">{$t('filters')}</label>
+        <TagSelector bind:selectedTagIds />
+      </div>
+
+      <!-- Operator Selection -->
+      {#if selectedTagIds.size > 1}
+        <div class="my-4 flex flex-col gap-2">
+          <SettingDropdown
+            title={$t('filter_operator')}
+            subtitle={$t('filter_operator_description')}
+            options={Object.values(operatorOptions)}
+            selectedOption={operatorOptions[selectedOperator]}
+            onToggle={(option) => {
+              const newOperator = Object.keys(operatorOptions).find(
+                (key) => operatorOptions[key as 'and' | 'or'] === option,
+              ) as 'and' | 'or';
+              if (newOperator) {
+                selectedOperator = newOperator;
+              }
+            }}
+          />
+        </div>
+      {/if}
+    </ModalBody>
+
+    <ModalFooter>
+      <HStack fullWidth>
+        <Button shape="round" color="secondary" fullWidth onclick={() => onClose()}>
+          {$t('cancel')}
+        </Button>
+        <Button type="submit" shape="round" fullWidth form="edit-dynamic-album-filters-form" {disabled}>
+          {$t('save')}
+        </Button>
+      </HStack>
+    </ModalFooter>
+  </form>
+</Modal>
diff --git a/web/src/lib/modals/SharedLinkCreateModal.svelte b/web/src/lib/modals/SharedLinkCreateModal.svelte
index b4b9eaf98..9ee4f714e 100644
--- a/web/src/lib/modals/SharedLinkCreateModal.svelte
+++ b/web/src/lib/modals/SharedLinkCreateModal.svelte
@@ -19,7 +19,12 @@
     editingLink?: SharedLinkResponseDto | undefined;
   }
 
-  let { onClose, albumId = $bindable(undefined), assetIds = $bindable([]), editingLink = undefined }: Props = $props();
+  let {
+    onClose,
+    albumId = $bindable(undefined),
+    assetIds = $bindable([]),
+    editingLink = undefined,
+  }: Props = $props();
 
   let sharedLink: string | null = $state(null);
   let description = $state('');
@@ -51,7 +56,9 @@
     })),
   ]);
 
-  let shareType = $derived(albumId ? SharedLinkType.Album : SharedLinkType.Individual);
+  let shareType = $derived(
+    albumId ? SharedLinkType.Album : SharedLinkType.Individual,
+  );
 
   $effect(() => {
     if (!showMetadata) {
@@ -154,6 +161,8 @@
       {/if}
     {/if}
 
+
+
     {#if shareType === SharedLinkType.Individual}
       {#if !editingLink}
         <div>{$t('create_link_to_share_description')}</div>
diff --git a/web/src/lib/utils/album-utils.ts b/web/src/lib/utils/album-utils.ts
index 1a4097b78..427b5d847 100644
--- a/web/src/lib/utils/album-utils.ts
+++ b/web/src/lib/utils/album-utils.ts
@@ -44,6 +44,16 @@ export const createAlbumAndRedirect = async (name?: string, assetIds?: string[])
   }
 };
 
+export const showCreateAlbumModal = async (assetIds?: string[]) => {
+  const { modalManager } = await import('$lib/managers/modal-manager.svelte');
+  const { default: CreateAlbumModal } = await import('$lib/modals/CreateAlbumModal.svelte');
+
+  const album = await modalManager.show(CreateAlbumModal, { assetIds });
+  if (album) {
+    await goto(`${AppRoute.ALBUMS}/${album.id}`);
+  }
+};
+
 /**
  * -------------
  * Album Sorting
diff --git a/web/src/routes/(user)/albums/+page.svelte b/web/src/routes/(user)/albums/+page.svelte
index 239c6cc38..8526f1572 100644
--- a/web/src/routes/(user)/albums/+page.svelte
+++ b/web/src/routes/(user)/albums/+page.svelte
@@ -1,16 +1,16 @@
 <script lang="ts">
-  import type { PageData } from './$types';
   import { scrollMemory } from '$lib/actions/scroll-memory';
-  import { AlbumFilter, albumViewSettings } from '$lib/stores/preferences.store';
-  import { createAlbumAndRedirect } from '$lib/utils/album-utils';
-  import UserPageLayout from '$lib/components/layouts/user-page-layout.svelte';
   import AlbumsControls from '$lib/components/album-page/albums-controls.svelte';
   import Albums from '$lib/components/album-page/albums-list.svelte';
-  import EmptyPlaceholder from '$lib/components/shared-components/empty-placeholder.svelte';
   import GroupTab from '$lib/components/elements/group-tab.svelte';
   import SearchBar from '$lib/components/elements/search-bar.svelte';
+  import UserPageLayout from '$lib/components/layouts/user-page-layout.svelte';
+  import EmptyPlaceholder from '$lib/components/shared-components/empty-placeholder.svelte';
   import { AppRoute } from '$lib/constants';
+  import { AlbumFilter, albumViewSettings } from '$lib/stores/preferences.store';
+  import { showCreateAlbumModal } from '$lib/utils/album-utils';
   import { t } from 'svelte-i18n';
+  import type { PageData } from './$types';
 
   interface Props {
     data: PageData;
@@ -52,7 +52,7 @@
     bind:albumGroupIds={albumGroups}
   >
     {#snippet empty()}
-      <EmptyPlaceholder text={$t('no_albums_message')} onClick={() => createAlbumAndRedirect()} />
+      <EmptyPlaceholder text={$t('no_albums_message')} onClick={() => showCreateAlbumModal()} />
     {/snippet}
   </Albums>
 </UserPageLayout>
diff --git a/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte b/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte
index aa535a30e..363d051d6 100644
--- a/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte
+++ b/web/src/routes/(user)/albums/[albumId=id]/[[photos=photos]]/[[assetId=id]]/+page.svelte
@@ -27,6 +27,7 @@
   import ButtonContextMenu from '$lib/components/shared-components/context-menu/button-context-menu.svelte';
   import MenuOption from '$lib/components/shared-components/context-menu/menu-option.svelte';
   import ControlAppBar from '$lib/components/shared-components/control-app-bar.svelte';
+  import FilterDisplay from '$lib/components/shared-components/filter-display.svelte';
   import {
     NotificationType,
     notificationController,
@@ -40,6 +41,7 @@
   import AlbumOptionsModal from '$lib/modals/AlbumOptionsModal.svelte';
   import AlbumShareModal from '$lib/modals/AlbumShareModal.svelte';
   import AlbumUsersModal from '$lib/modals/AlbumUsersModal.svelte';
+  import DynamicAlbumFiltersModal from '$lib/modals/DynamicAlbumFiltersModal.svelte';
   import QrCodeModal from '$lib/modals/QrCodeModal.svelte';
   import SharedLinkCreateModal from '$lib/modals/SharedLinkCreateModal.svelte';
   import { AssetInteraction } from '$lib/stores/asset-interaction.svelte';
@@ -68,6 +70,7 @@
     deleteAlbum,
     getAlbumInfo,
     updateAlbumInfo,
+    type AlbumResponseDto,
     type AlbumUserAddDto,
   } from '@immich/sdk';
   import { Button, IconButton } from '@immich/ui';
@@ -80,6 +83,7 @@
     mdiImageOutline,
     mdiImagePlusOutline,
     mdiLink,
+    mdiPencilOutline,
     mdiPlus,
     mdiPresentationPlay,
     mdiShareVariantOutline,
@@ -105,6 +109,7 @@
   let isCreatingSharedAlbum = $state(false);
   let isShowActivity = $state(false);
   let albumOrder: AssetOrder | undefined = $state(data.album.order);
+  let showDynamicAlbumEditModal = $state(false);
 
   const assetInteraction = new AssetInteraction();
   const timelineInteraction = new AssetInteraction();
@@ -179,6 +184,18 @@
 
   const refreshAlbum = async () => {
     album = await getAlbumInfo({ id: album.id, withoutAssets: true });
+
+    // For dynamic albums, also refresh the timeline manager to get new filtered assets
+    if (album.dynamic && viewMode === AlbumPageViewMode.VIEW) {
+      // Clear the timeline manager's cache and force a complete reload
+      timelineManager.months = [];
+      await timelineManager.updateOptions({
+        albumId: album.id,
+        order: albumOrder,
+        // Add a unique timestamp to ensure options are always different
+        _forceReload: Date.now(),
+      });
+    }
   };
   const handleAddAssets = async () => {
     const assetIds = timelineInteraction.selectedAssets.map((asset) => asset.id);
@@ -320,7 +337,8 @@
     }
   });
 
-  let album = $derived(data.album);
+  let album = $state(data.album);
+
   let albumId = $derived(album.id);
 
   $effect(() => {
@@ -439,6 +457,26 @@
       }
     }
   };
+
+  const handleEditDynamicAlbumFilters = async () => {
+    const result = await modalManager.show(DynamicAlbumFiltersModal, { album });
+
+    if (
+      result &&
+      typeof result === 'object' &&
+      'action' in result &&
+      result.action === 'updated' &&
+      'album' in result
+    ) {
+      album = result.album as AlbumResponseDto;
+
+      // For dynamic albums, refresh the album data and timeline manager to get new filtered assets
+      if (album.dynamic && viewMode === AlbumPageViewMode.VIEW) {
+        // First refresh the album data to get updated assetCount
+        await refreshAlbum();
+      }
+    }
+  };
 </script>
 
 <div class="flex overflow-hidden" use:scrollMemoryClearer={{ routeStartsWith: AppRoute.ALBUMS }}>
@@ -524,23 +562,52 @@
               {/if}
               <!-- ALBUM DESCRIPTION -->
               <AlbumDescription id={album.id} bind:description={album.description} {isOwned} />
+
+              <!-- DYNAMIC ALBUM FILTERS -->
+              {#if album.dynamic && album.filters && typeof album.filters === 'object'}
+                {@const filters = album.filters as any}
+                {#if filters.tags || filters.people || filters.location || filters.dateRange || filters.assetType || filters.metadata}
+                  <div class="mt-6">
+                    <div class="mb-3 flex items-center justify-between">
+                      <h3 class="text-sm font-medium text-gray-900 dark:text-white">
+                        {$t('filters')}
+                      </h3>
+                      {#if isOwned}
+                        <IconButton
+                          aria-label={$t('edit')}
+                          color="secondary"
+                          size="small"
+                          shape="round"
+                          icon={mdiPencilOutline}
+                          onclick={handleEditDynamicAlbumFilters}
+                        />
+                      {/if}
+                    </div>
+                    <FilterDisplay filters={album.filters} />
+                  </div>
+                {/if}
+              {/if}
             </section>
           {/if}
 
           {#if album.assetCount === 0}
             <section id="empty-album" class=" mt-[200px] flex place-content-center place-items-center">
               <div class="w-[300px]">
-                <p class="text-xs dark:text-immich-dark-fg">{$t('add_photos').toUpperCase()}</p>
-                <button
-                  type="button"
-                  onclick={() => (viewMode = AlbumPageViewMode.SELECT_ASSETS)}
-                  class="mt-5 bg-subtle flex w-full place-items-center gap-6 rounded-2xl border px-8 py-8 text-immich-fg transition-all hover:bg-gray-100 dark:hover:bg-gray-500/20 hover:text-immich-primary dark:border-none dark:text-immich-dark-fg dark:hover:text-immich-dark-primary"
-                >
-                  <span class="text-text-immich-primary dark:text-immich-dark-primary"
-                    ><Icon path={mdiPlus} size="24" />
-                  </span>
-                  <span class="text-lg">{$t('select_photos')}</span>
-                </button>
+                {#if !album.dynamic}
+                  <p class="text-xs dark:text-immich-dark-fg">{$t('add_photos').toUpperCase()}</p>
+                  <button
+                    type="button"
+                    onclick={() => (viewMode = AlbumPageViewMode.SELECT_ASSETS)}
+                    class="mt-5 bg-subtle flex w-full place-items-center gap-6 rounded-2xl border px-8 py-8 text-immich-fg transition-all hover:bg-gray-100 dark:hover:bg-gray-500/20 hover:text-immich-primary dark:border-none dark:text-immich-dark-fg dark:hover:text-immich-dark-primary"
+                  >
+                    <span class="text-text-immich-primary dark:text-immich-dark-primary"
+                      ><Icon path={mdiPlus} size="24" />
+                    </span>
+                    <span class="text-lg">{$t('select_photos')}</span>
+                  </button>
+                {:else}
+                  <p class="text-center text-gray-500 dark:text-gray-400">{$t('no_assets_found_in_dynamic_album')}</p>
+                {/if}
               </div>
             </section>
           {/if}
@@ -617,7 +684,7 @@
           {#snippet trailing()}
             <CastButton />
 
-            {#if isEditor}
+            {#if isEditor && !album.dynamic}
               <IconButton
                 variant="ghost"
                 shape="round"
@@ -699,7 +766,7 @@
         </ControlAppBar>
       {/if}
 
-      {#if viewMode === AlbumPageViewMode.SELECT_ASSETS}
+      {#if viewMode === AlbumPageViewMode.SELECT_ASSETS && !album.dynamic}
         <ControlAppBar onClose={handleCloseSelectAssets}>
           {#snippet leading()}
             <p class="text-lg dark:text-immich-dark-fg">
@@ -712,16 +779,18 @@
           {/snippet}
 
           {#snippet trailing()}
-            <button
-              type="button"
-              onclick={handleSelectFromComputer}
-              class="rounded-lg px-6 py-2 text-sm font-medium text-immich-primary transition-all hover:bg-immich-primary/10 dark:text-immich-dark-primary dark:hover:bg-immich-dark-primary/25"
-            >
-              {$t('select_from_computer')}
-            </button>
-            <Button size="small" disabled={!timelineInteraction.selectionActive} onclick={handleAddAssets}
-              >{$t('done')}</Button
-            >
+            {#if !album.dynamic}
+              <button
+                type="button"
+                onclick={handleSelectFromComputer}
+                class="rounded-lg px-6 py-2 text-sm font-medium text-immich-primary transition-all hover:bg-immich-primary/10 dark:text-immich-dark-primary dark:hover:bg-immich-dark-primary/25"
+              >
+                {$t('select_from_computer')}
+              </button>
+              <Button size="small" disabled={!timelineInteraction.selectionActive} onclick={handleAddAssets}
+                >{$t('done')}</Button
+              >
+            {/if}
           {/snippet}
         </ControlAppBar>
       {/if}
diff --git a/web/src/routes/(user)/sharing/+page.svelte b/web/src/routes/(user)/sharing/+page.svelte
index a55452b5d..22c4bacab 100644
--- a/web/src/routes/(user)/sharing/+page.svelte
+++ b/web/src/routes/(user)/sharing/+page.svelte
@@ -13,7 +13,7 @@
     SortOrder,
     type AlbumViewSettings,
   } from '$lib/stores/preferences.store';
-  import { createAlbumAndRedirect } from '$lib/utils/album-utils';
+  import { showCreateAlbumModal } from '$lib/utils/album-utils';
   import { Button, HStack, Text } from '@immich/ui';
   import { mdiLink, mdiPlusBoxOutline } from '@mdi/js';
   import { t } from 'svelte-i18n';
@@ -41,7 +41,7 @@
     <HStack gap={0}>
       <Button
         leadingIcon={mdiPlusBoxOutline}
-        onclick={() => createAlbumAndRedirect()}
+        onclick={() => showCreateAlbumModal()}
         size="small"
         variant="ghost"
         color="secondary"
